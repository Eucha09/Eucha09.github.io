[ { "title": "[멀티쓰레드] AutoResetEvent", "url": "/posts/AutoResetEvent/", "categories": "서버, 멀티쓰레드 프로그래밍", "tags": "Lock, AutoResetEvent, ManualResetEvent, Mutex", "date": "2022-06-01 15:02:00 +0900", "snippet": "Lock 구현 이론Lock 구현 이론앞 포스트에서 Lock 구현 방법에 대해 얘기를 해보았다. 대략 3가지 방법이 있었는데, 그냥 무작정 기다린다. 일단 다른 작업으로 돌아가 있다가 나중에 다시 와본다. Event call back 방식으로 누군가에게 다시 사용할 수 있는 상태가 되면 호출해 달라한다.1번 방법은 SpinLock이라고 부른다고 하였고 이전 포스트에서 직접 구현해보기도 하였다. SpinLock2번 방법은 그냥 무작정 기다리는것이 아닌 일단 CPU 소유권을 양보하였다가 나중에 다시 시도하는 방식이다. 이또한 Context Switching을 배워보면서 간단하게 구현해보았다. Context Switching3번 방법은 커널(운영체제)한테 Event call back 방식으로 나중에 다시 사용가능해지면 호출해달라고 부탁해놓고 나오는 방식인데 이번 포스트에서 AutoResetEvent를 사용해 구현해볼 것이다.AutoResetEventC#에서는 AutoResetEvent 기능이 있는데 쉽게 말해 Thread.Sleep()와 같이 쉬고 있다가 다른 쓰레드가 신호를 보내면 깨어나 다음 문장을 실행할 수 있도록 해주는 기능이다.이를 이용해 누군가가 이미 Lock을 점유하고 있다면 WaitOne()을 호출해 잠들어있다가 누군가가 Set()을 호출해 신호를 준다면 그때 깨어나 자신이 Lock을 점유하면 된다.AutoResetEvent를 이용해 Lock을 구현해보면 아래와 같다.class Lock{ // bool 변수라고 생각하면 편하다. &amp;lt;- 커널 // bool _available = true; AutoResetEvent _available = new AutoResetEvent(true); public void Enter() { _available.WaitOne(); // true일때까지 기다린다. //_available.Reset(); // _available = false, AutoResetEvent는 자동으로 해준다. } public void Exit() { _available.Set(); // _available = true; }}AutoResetEvent 사용법은 하나의 bool 변수라고 생각하면 편하다. 다만 bool값을 커널에서 관리한다.코드를 살펴보자면 입장하려는데 false라면 true로 바뀔때까지 기다리고 true이면 입장하면서 false로 바꾼다(다른 쓰레드가 못들어오도록). 그리고 나갈 때는 true로 다시 바꾼다.원래 Reset()이라고 false로 바꾸는 함수가 있는데 AutoResetEvent는 자동으로 해준다.Lock을 구현했으니 간단하게 테스트를 해보자.class Program{ static int _num = 0; static Lock _lock = new Lock(); static void Thread_1() { for (int i = 0; i &amp;lt; 100000; i++) { _lock.Enter(); // 자물쇠로 잠군다. (혹시나 잠겨 있으면 기다린다.) _num++; _lock.Exit(); // 잠금을 푼다. } } static void Thread_2() { for (int i = 0; i &amp;lt; 100000; i++) { _lock.Enter(); // 자물쇠로 잠군다. (혹시나 잠겨 있으면 기다린다.) _num--; _lock.Exit(); // 잠금을 푼다. } } static void Main(String[] args) { Task t1 = new Task(Thread_1); Task t2 = new Task(Thread_2); t1.Start(); t2.Start(); Task.WaitAll(t1, t2); Console.WriteLine(_num); }}0실행해보면 정상적으로 0이 잘 출력되는 것을 볼 수 있다. 다만 좀 느리다는 것을 느낄 수 있을 것이다. AutoResetEvent가 커널단에서 실행되다보니 좀 느리다는 단점이 있다. 그렇기에 위처럼 Lock을 걸고 하는 작업이 오래걸리지 않는다면 SpinLock처럼 그냥 while문을 돌면서 기다리는게 나을 수 있고 만약 Lock을 걸고 하는 작업이 오래걸리는 작업이라면 위처럼 커널한테 신호보내달라는 식으로 맡기는 방법이 나을 수 있다.AutoResetEvent는 꼭 Lock에서 말고도 사용될 수 있으니 알아두면 좋다.추가적으로 AutoResetEvent와 비슷한 ManualResetEvent와 이러한 Event말고도 비슷하게 사용할 수 있는 Mutex에 대해 간단히 알아보려고 한다.ManualResetEventManualResetEvent또한 AutoResetEvent와 거의 동일한 기능을 하지만 한가지 다른 점은 WaitOne()을 하였을 때 Reset()을 자동으로 안해준다는 점이다.그래서 AutoResetEvent 대신 ManualResetEvent를 사용한다면 아래와 같이 Reset()을 넣어주어야 한다.class Lock{ // bool 변수라고 생각하면 편하다. &amp;lt;- 커널 // bool _available = true; ManualResetEvent _available = new ManualResetEvent(true); public void Enter() { _available.WaitOne(); // true일때까지 기다린다. _available.Reset(); // _available = false, ManualResetEvent는 자동으로 안해준다. } public void Exit() { _available.Set(); // _available = true; }}다만 ManualResetEvent를 사용하여 Lock을 구현했을 때 테스트를 해보면 0이 안나오는 것을 볼 수 있다.class Program{ static int _num = 0; static Lock _lock = new Lock(); static void Thread_1() { for (int i = 0; i &amp;lt; 100000; i++) { _lock.Enter(); // 자물쇠로 잠군다. (혹시나 잠겨 있으면 기다린다.) _num++; _lock.Exit(); // 잠금을 푼다. } } static void Thread_2() { for (int i = 0; i &amp;lt; 100000; i++) { _lock.Enter(); // 자물쇠로 잠군다. (혹시나 잠겨 있으면 기다린다.) _num--; _lock.Exit(); // 잠금을 푼다. } } static void Main(String[] args) { Task t1 = new Task(Thread_1); Task t2 = new Task(Thread_2); t1.Start(); t2.Start(); Task.WaitAll(t1, t2); Console.WriteLine(_num); }}9이러한 결과가 나오는 이유는 Lock에서 기다리고 잠구는 작업을 2단계로 나누어서 처리를 하고 있기 때문이다. 그렇기에 ManualResetEvent로 Lock을 구현하기에는 적합하지 않다라고 볼 수 있다.굳이 Lock이 아니여도 이러한 EventCallback 방식은 다른 곳에 쓰일 때도 있으니 차이만 알아두자.마지막으로 이러한 Event말고도 비슷하게 사용할 수 있는 mutex를 알아보자.MutexMutex또한 Lock의 기능을 가지고 있기에 Lock과 동일하게 사용할 수 있다.간단하게 사용해보자면 아래와 같이 사용해 볼 수 있다.class Program{ static int _num = 0; static Mutex _lock = new Mutex(); // Mutex 사용 static void Thread_1() { for (int i = 0; i &amp;lt; 100000; i++) { _lock.WaitOne(); // 자물쇠로 잠군다. (혹시나 잠겨 있으면 기다린다.) _num++; _lock.ReleaseMutex(); // 잠금을 푼다. } } static void Thread_2() { for (int i = 0; i &amp;lt; 100000; i++) { _lock.WaitOne(); // 자물쇠로 잠군다. (혹시나 잠겨 있으면 기다린다.) _num--; _lock.ReleaseMutex(); // 잠금을 푼다. } } static void Main(String[] args) { Task t1 = new Task(Thread_1); Task t2 = new Task(Thread_2); t1.Start(); t2.Start(); Task.WaitAll(t1, t2); Console.WriteLine(_num); }}0사용법은 우리가 구현한 Lock과 거의 동일하게 사용해볼 수 있고, 실행시켜보면 정상적으로 0이 나오는것을 볼 수 있다.그러나 Mutex는 앞에서 Event로 구현한 Lock보다 더 느린것을 느낄 수 있다. AutoResetEvent와 동일하게 커널까지 내려가서 실행되며, AutoResetEvent의 경우 커널에서 사실상 bool 값 하나를 가지고 처리하지만 Mutex의 경우 누가 잠구었는지, 몇번 잠구었는지 등 좀 더 많은 정보를 가지고 처리하기 때문에 좀 더 느린것이다." }, { "title": "[멀티쓰레드] Context Switching", "url": "/posts/ContextSwitching/", "categories": "서버, 멀티쓰레드 프로그래밍", "tags": "Lock, Context Switching", "date": "2022-05-30 15:51:00 +0900", "snippet": "Context SwitchingContext Switching이란 하나의 프로세스(또는 쓰레드)가 CPU를 사용 중인 상태에서 다른 프로세스(또는 쓰레드)가 CPU를 사용하도록 교체하는 작업을 말한다. 이 과정속에서 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 상태를 적재하는 작업이 이루어진다.보통 일반적으로 운영체제가 각 프로세스한테 실행 시간(timeslice)을 배정해서, 그 시간만큼 프로세스가 실행되고, 시간이 끝나면 CPU 소유권을 반납하여 다른 프로세스가 소유권을 받아 실행되도록 한다(Context Switching).근데 만약 CPU 소유권을 받았는데 딱히 할일이 없다면 미연에 소유권을 받납할 수도 있다.앞 포스트에서의 SpinLock을 예로 들어보자면 SpinLock의 경우 Lock을 얻지못했다면 얻을 때까지 계속 루프를 돌며 재시도를 하게 된다. 이때 만약 Lock을 획득한 쓰레드가 꽤나 오래걸리는 작업을 하고 있다고 한다면 Lock을 기다리고 있는 쓰레드는 계속 무한루프를 돌면서 기다리게 된다.SpinLock에 대한 내용이때 무작정 기다리고 있는것 보단 CPU 소유권을 다른 쓰레드에게 넘겨주어 기다리는 동안 다른 작업을 하고 있도록 한다면 나름 효율적이지 않을까라는 생각을 할 수 있을 것이다.언어마다 다르겠지만 C#의 경우 Thread.Sleep()와 Thread.Yield()를 사용해볼 수 있다.Thread.Sleep(), Thread.Yield()크게 CPU 소유권을 양보하는 방법으로 Thread.Sleep()와 Thread.Yield()로 나누어 볼 수 있지만 Thread.Sleep()또한 인자로 양수를 전달하는 경우와 그냥 0을 전달하는 경우로 나누어볼 수 있기에 크게 3가지 방법이 있다. 일단 3가지 방법을 비교해보자면 아래와 같다.Thread.Sleep(1) // 무조건 1ms 정도 쉰다. 쉬는 동안 다른 쓰레드한테 양보Thread.Sleep(0) // 나보다 우선순위가 같거나 높은 쓰레드가 있다면 양보Thread.Yield(); // 지금 실행가능한 쓰레드가 있으면 양보약간의 차이는 있지만 기본적으로 자기가 할당받은 실행 시간(timeslice)을 반납하면서 다른 프로세스(또는 쓰레드)한테 양보한다는 것은 똑같다. 사실 어느것을 선택해도 큰 차이는 없어 아무거나 사용해도 무방하다. 다만 이러한 차이가 있다는 것은 알아두면 좋겠다.이전 포스트의 SpinLock 코드에서 이를 사용해본다면 아래와 같이 사용해 볼 수 있다.class SpinLock{ int _locked = 0; public void Enter() { while (true) { // Lock 획득 시도 if (Interlocked.CompareExchange(ref _locked, 1, 0) == 0) break; // Lock 획득을 실패했다면 나중에 다시 시도 Thread.Yield(); // CPU 소유권 양보 } } public void Exit() { _locked = 0; }}사실 위 코드는 SpinLock 개념을 벗어났기 때문에 SpinLock이라고 부르진 못하겠지만 이또한 일종의 Lock 구현하는 방법 중 하나라고 할 수 있겠다.다만 여기서 꼭 유의할 점은 CPU 소유권을 양보한다는 것이 결코 가볍게 이루어지는 작업이 아니라는 점이다. Context Switching이 이루어지는 과정속에서 현재 프로세스(또는 쓰레드)에 대한 정보를 메모리에 저장하고, 다른 프로세스(또는 쓰레드)에 대한 정보를 메모리에서 불어오는 등 이런저런 복잡한 작업들을 하기 때문에 Context Switching이 많이 발생하면 CPU입장에서는 꽤나 부담이 될 수 있다. 그렇기에 경우에 따라 기존 SpinLock처럼 계속 루프를 돌면서 시도하는것이 오히려 효율적일 수도 있다." }, { "title": "[멀티쓰레드] SpinLock", "url": "/posts/SpinLock/", "categories": "서버, 멀티쓰레드 프로그래밍", "tags": "Lock, SpinLock", "date": "2022-04-05 11:45:00 +0900", "snippet": "SpinLockSpinLock은 임계 구역(Critical Section)에 진입이 불가능할 때 진입이 가능할 때까지 루프를 돌면서 재시도하는 방식으로 구현된 락을 가르킨다.화장실문에 비유하자면 누가 화장실에 들어가 문을 잠궜을 때 내가 들어갈 수 있을 때까지 문을 열려고 시도하는 것이다.SpinLock 구현SpinLock을 구현하는 방법은 쉽지만 중요한 부분을 놓치기가 쉽다.일단 그냥 단순히 생각나는대로 구현해보자. 먼저 인터페이스로는 들어가고 나오는 함수가 있어야 할 것이다. 그리고 들어가려고 할 때 이미 누가 lock을 걸어뒀다면 lock이 풀릴 때까지 루프 형식으로 기다려야할 것이다. 위 사항 그대로 구현해보면 아래와 같이 구현해볼 수 있다.class SpinLock{ bool _locked = false; public void Enter() { while(_locked) { // 이미 잠겨 있으면 풀릴 때까지 기다린다. } _locked = true; // 잠군다. } public void Exit() { _locked = false; }}코드만 보았을 땐 별 문제없어 보인다. 그렇다면 정상적으로 lock 기능을 하는지 테스트해보자.간단하게 두 쓰레드로 각각 num++, num–를 해주어 Race Condition이 발생하는지 확인해보면 된다.static int _num = 0;static SpinLock _lock = new SpinLock(); // 직접 구현한 SpinLockstatic void Thread_1(){ for (int i = 0; i &amp;lt; 100000; i++) { _lock.Enter(); // 자물쇠로 잠군다. (혹시나 잠겨 있으면 기다린다.) _num++; _lock.Exit(); // 잠금을 푼다. }}static void Thread_2(){ for (int i = 0; i &amp;lt; 100000; i++) { _lock.Enter(); // 자물쇠로 잠군다. (혹시나 잠겨 있으면 기다린다.) _num--; _lock.Exit(); // 잠금을 푼다. }}static void Main(String[] args){ Task t1 = new Task(Thread_1); Task t2 = new Task(Thread_2); t1.Start(); t2.Start(); Task.WaitAll(t1, t2); Console.WriteLine(_num);}-14365정상적으로 동작했다면 0이 나와야하지만 결과로 0이 아닌 수가 나온것으로 보아 방금 구현해본 SpinLock에 문제가 있음을 짐작해볼 수 있다.어떤부분이 문제였을까.답부터 말하자면 Race Condition을 막기위해 SpinLock을 구현한 것이었지만 정작 방금 구현한 SpinLock 내부에서 Race Condition이 발생한 것이다.예를 들어 지금 구현된 SpinLock에 두 쓰레드가 동시에 Enter()를 호출하였다고 해보자. 그러면 동시에 while문에서 _lock이 true인지 false인지 검사해볼 것이고 false이기 때문에 둘 다 거의 동시에 while문에서 빠져나와 _lock을 true로 바꾸고 임계 구역(Critical Section)에 들어가게 될 것이다.이러한 문제가 발생한 이유는 Enter()에서 검사하는 행위, 잠그는 행위 이렇게 두 단계로 나눠서 처리하였기 때문이다.그렇다면 이 두 단계를 한번에 처리를 한다면 해결될 것이다. 이전 포스트에서 언급한 원자적 연산을 이용하면 된다.Race Condition과 Interlocked에 대한 내용언어마다 보통 원자적 연산을 지원해주고 있으며 C#에서는 Interlocked를 이용하면 된다.아까 SpinLock을 수정해보면 아래와 같다.class SpinLock{ int _locked = 0; public void Enter() { while (true) { if (Interlocked.CompareExchange(ref _locked, 1, 0) == 0) break; } } public void Exit() { _locked = 0; }}이해를 위해 Interlocked.CompareExchange(ref _locked, 1, 0) 부분을 해석해보자면 _locked가 0인 경우 1로 바꿔주며 반환은 바뀌기 전 원래 값을 반환해준다. _lock이 0인 경우에는 0이기 때문에 1로 바뀌고 이전의 값 0이 반환된다. _lock이 1인 경우에는 0이 아니기 때문에 바뀌지 않고 원래 값인 1이 반환된다.이러한 연산을 CAS(Compare-And-Swap) 연산이라고 하며, 검사와 잠그는 행위를 원자적으로 한 번에 해줌으로써 아까 SpinLock의 문제를 해결한 것이다. 아까 전 테스트를 다시 해보면 0이 정상으로 출력되는 것을 볼 수 있을 것이다." }, { "title": "[멀티쓰레드] Lock 구현 이론", "url": "/posts/Lock%EA%B5%AC%ED%98%84%EC%9D%B4%EB%A1%A0/", "categories": "서버, 멀티쓰레드 프로그래밍", "tags": "Lock", "date": "2022-04-04 14:00:00 +0900", "snippet": "Lock 구현 이론Lock을 직접 구현해본다고 생각하고 Lock이 어떤 철학으로 어떤식으로 구현될 수 있을지 생각해보자.일단 기본적으로 당연히 Lock의 역할을 하기 위해서는 Critical Section(임계 구역)에 두 프로세스가 동시에 진입하지 못하도록 해야할 것이다. 그 다음으로는 이미 다른 프로세스가 들어와 사용하고 있을 때 어떻게 처리할지를 생각해봐야 할 것이다.일상생활에 비유해보자면 공용 화장실에 이미 누가 들어가 문을 잠군 상태이고 난 문앞에서 기다리고 있는 상황이다.이때 내가 할 수 있는 행동으로는 아래와 같을 것이다. 그냥 무작정 기다린다. 일단 돌아가 있다가 나중에 다시 와본다. 주변에 직원분이 있다면 부탁드리고 돌아와 있다가 직원분이 화장실이 비었다고 전달해주면 그때 다시 가본다. 기타…Lock을 구현할 때도 위와 동일하다. 이미 누가 점유해 사용하고 있을 때 아래와 같이 대처할 수 있을 것이다. 그냥 무작정 기다린다. 일단 다른 작업으로 돌아가 있다가 나중에 다시 와본다. Event call back 방식으로 누군가에게 다시 사용할 수 있는 상태가 되면 호출해 달라한다.1번 방법은 실제로 있는 개념으로 Spin Lock이라고 한다. 그냥 무작정 기다리는 형태이기 때문에 구현은 단순하겠지만, 기다린다는 것이 실제로 가만히 있는 것이아니라 while문 형식으로 무작정 시도하는 형태이기 때문에 작업이 결코 가볍진 않다.2번 방법의 경우 무작정 체크를 하는 것이 아닌 일단 다른 작업으로 돌아가 있다가 랜덤한 시간 이후에 다시 돌아와 체크하는 방식이다. 1번과 다르게 기다리는 동안 다른 작업을 할 수 있다는 장점이 있지만, 작업을 계속 왔다 갔다하는 것이 결코 가볍지 않고 잠깐 다른 작업을 하고 오는 사이에 또다른 쓰레드가 점유해 있을 수도 있다.3번 방법은 2번과 비슷하지만 랜덤한 시간 이후에 다시 돌아오는 것이 아니라 커널(운영체제)한테 Event call back 방식으로 나중에 다시 사용가능해지면 호출해달라고 부탁해놓고 나오는 방식이다. 이렇게 할 경우 매번 돌아와 체크할 필요가 없어진다는 장점이 있지만, 이렇게 부탁하는 쓰레드가 많아질 수록 커널(운영체제) 입장에서는 부담이 커질 수 있다." }, { "title": "[멀티쓰레드] DeadLock", "url": "/posts/DeadLock/", "categories": "서버, 멀티쓰레드 프로그래밍", "tags": "Lock, 교착상태, DeadLock", "date": "2022-04-04 13:00:00 +0900", "snippet": "DeadLockDeadLock(데드락, 교착상태)이란 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태를 가리킨다.DeadLock 상황을 간단하게 만들어보자.예를 들어 SessionManager와 User들을 관리하는 UserManager 두 클래스가 있다. 멀티쓰레드 환경에서 돌아가다보니 각 클래스에서는 lock을 하나씩 쥐고 있고 서로 호출할 일이 있다고 해보자.SesstionManagerclass SessionManager{ static object _lock = new object(); public static void TestSession() { lock(_lock) // 다른 쓰레드는 못들어오게 lock을 걸고 작업한다. { } } public static void Test() { lock(_lock) // 다른 쓰레드는 못들어오게 lock을 걸고 작업한다. { UserManager.TestUser(); // UserManager 호출 } }}UserManagerclass UserManager{ static object _lock = new object(); public static void TestUser() { lock(_lock) // 다른 쓰레드는 못들어오게 lock을 걸고 작업한다. { } } public static void Test() { lock(_lock) // 다른 쓰레드는 못들어오게 lock을 걸고 작업한다. { SessionManager.TestSession(); // SessionManager 호출 } }}위 처럼 간단히 정의한 다음에 두 클래스를 서로 다른 쓰레드로 수행시키면 어떻게 될까.static void Thread_1(){ for (int i = 0; i &amp;lt; 10000; i++) { SessionManager.Test(); }}static void Thread_2(){ for (int i = 0; i &amp;lt; 10000; i++) { UserManager.Test(); }}static void Main(String[] args){ Task t1 = new Task(Thread_1); Task t2 = new Task(Thread_2); t1.Start(); t2.Start(); Task.WaitAll(t1, t2); Console.WriteLine(&quot;쓰레드 무사히 종료&quot;);}실행시켜보면 알겠지만 쓰레드가 종료되지 않는 것을 볼 수 있을 것이다.위 상황을 해석해보면 서로 자신의 lock을 걸어둔채로 상대방의 lock이 풀릴때까지 하염없이 기다리고 있는 상황이다.출처: DeadLock 이란이처럼 서로 상대방의 작업이 끝나기만을 하염없이 기다리고 있는 상태를 교착상태 혹은 DeadLock이라고 한다.DeadLock은 보통 실행시켜보기 전까진 발견되기 쉽지않다. 그렇다보니 대부분의 경우 실행시켜보고 실제로 발생한 다음에 고치는 경우가 많다. 그만큼 DeadLock이 까다롭고 관리하기 쉽지 않다는 것이다.DeadLock 해결방법DeadLock을 해결하는 방법은 여러가지가 있지만 사실 완전히 막는 것은 힘들다. 그렇다보니 대부분의 방법이 예방 또는 방지하는 방법이다. 간단하게만 살펴보자면 아래와 같다.DeadLock 예방DeadLock이 발생하려면 아래 4가지 조건을 모두 만족해야한다. 상호 배제(Mutual exclusion): 자원은 한 번에 한 프로세스만이 사용할 수 있어야 한다. 점유 대기(Hold and wait): 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다. 비선점(No preemption): 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다. 순환 대기 (Circular wait): 프로세스의 집합 {P0, P1, ,…Pn}에서 P0는 P1이 점유한 자원을 대기하고 P1은 P2가 점유한 자원을 대기하고 P2…Pn-1은 Pn이 점유한 자원을 대기하며 Pn은 P0가 점유한 자원을 요구해야 한다.이 조건 중에서 한 가지라도 만족하지 않으면 DeadLock은 발생하지 않는다. 이 점을 이용하여 4가지 조건중 한가지를 막음으로써 DeadLock이 발생하지 않도록 예방하는 것이다. 다만 이 방법은 자원 사용의 효율성이 떨어지고 비용이 많이 드는 문제점이 있다.DeadLock 회피자원이 어떻게 요청될지에 대해 사전에 검사하여 회피하는 방법이다.교착 상태 회피하기 위한 알고리즘으로 크게 두가지가 있다. 자원 할당 그래프 알고리즘 (Resource Allocation Graph Algorithm) 은행원 알고리즘 (Banker’s algorithm)DeadLock 무시위 예방 혹은 회피기법을 사용하기에는 비용이 크다보니 성능에 큰 영향을 미칠 수 있게 된다. 그렇기 때문에 데드락의 발생 확률이 비교적 낮은 경우 별다른 조치를 취하지 않는 경우도 있다.DeadLock 탐지 및 회복DeadLock을 탐지하는 알고리즘을 넣어 DeadLock이 발생했는지를 탐지하고 DeadLock이 발생했을 경우 회복하는 방법이다. 이 역시 성능에 큰 영향을 미칠 수 있다." }, { "title": "[멀티쓰레드] Lock 기초", "url": "/posts/Lock%EA%B8%B0%EC%B4%88/", "categories": "서버, 멀티쓰레드 프로그래밍", "tags": "경쟁상태, Race Condition, 임계 구역, Critical Section, 상호 배제, Mutual exclusion, DeadLock, Monitor, Lock", "date": "2022-03-31 14:30:00 +0900", "snippet": "Critical Section코드 상에서 Race Condition(경쟁 상태)이 발생할 수 있는 구역을 Critical Section(임계 구역)이라고 한다.Critical Section에서 발생할 수 있는 Race Condition 문제를 해결하기 위해서는 Interlocked 등의 Atomic Operation을 사용해 볼 수 도 있겠지만 간단한 정수 연산만 할 수 있는 등 복잡한 작업을 처리하기에는 한계가 있다.Race Condition과 Interlocked에 대한 내용그렇다면 이 Critical Section 문제를 어떻게 해결할 수 있을까.먼저 Monitor를 사용해볼 수 있다.MonitorMonitor는 특정 코드 부분을 배타적으로 Locking하는 기능을 가지고 있다.C#에서는 아래와 같이 사용해 볼 수 있다.static int number = 0;static object _obj = new object(); // 자물쇠 역할static void Thread_1(){ for (int i = 0; i &amp;lt; 100000; i++) { Monitor.Enter(_obj); // 자물쇠로 잠군다. (혹시나 잠겨 있으면 기다린다.) // Critical Section number++; Monitor.Exit(_obj); // 잠금을 푼다. }}static void Thread_2(){ for (int i = 0; i &amp;lt; 100000; i++) { Monitor.Enter(_obj); // 자물쇠로 잠군다. (혹시나 잠겨 있으면 기다린다.) // Critical Section number--; Monitor.Exit(_obj); // 잠금을 푼다. }}static void Main(String[] args){ Task t1 = new Task(Thread_1); Task t2 = new Task(Thread_2); t1.Start(); t2.Start(); Task.WaitAll(t1, t2); Console.WriteLine(number);}0Monitor는 쉽게 말해 자물쇠로 잠구고 다른 쓰레드가 못들어오도록 하는 기능이라고 생각하면 된다. 위처럼 다른 쓰레드는 접근을 못하게 하는 것을 Mutual exclusion(상호 배제)이라고 한다.이처럼 Monitor를 사용하여 Critical Section 문제를 해결해 볼 수도 있지만 다른 문제가 발생할 수 있다. Monitor.Enter()를 해주면 꼭 마지막엔 Monitor.Exit()를 해주어야 하는데 만약 중간에 예기치 못한 일로 Monitor.Exit()를 해주지 못하면 문제가 발생한다.static int number = 0;static object _obj = new object(); // 자물쇠 역할static void Thread_1(){ for (int i = 0; i &amp;lt; 100000; i++) { Monitor.Enter(_obj); // 자물쇠로 잠군다. (혹시나 잠겨 있으면 기다린다.) // Critical Section number++; // 예기치 못한 일로 종료 return; Monitor.Exit(_obj); // 잠금을 푼다. }}static void Thread_2(){ for (int i = 0; i &amp;lt; 100000; i++) { Monitor.Enter(_obj); // 자물쇠로 잠군다. (혹시나 잠겨 있으면 기다린다.) // Critical Section number--; Monitor.Exit(_obj); // 잠금을 푼다. }}위처럼 Monitor.Exit()을 해주지 못한채로 작업이 종료되면 다른 쓰레드는 계속 접근을 못한채로 무한히 기다리게 된다. 자물쇠로 잠그고는 풀어놓지 않은채로 가버린 것이다. 이러한 상태을 DeadLock 이라고 한다.아무튼 이러한 문제는 어떻게 해결해야할까. 일단 try문을 사용해 예외적인 문제가 발생해도 Monitor.Exit()가 수행되도록 할 순 있다.try{ Monitor.Enter(_obj); // Critical Section}finally // try에서 어떤 문제가 발생해도 무조건 실행된다.{ Monitor.Exit(_obj);}하지만 이렇게 일일이 try finally를 사용해주는 건 매번 번거러운 일이 아닐수가 없다.그렇기에 좀 더 편리하게 사용할 수 있는 기능이 있다. 바로 lock이다.lock아래 코드를 통해 사용법부터 보자면 이전 것보다 훨씬 간편하다는 것을 느낄 수 있을 것이다.static int number = 0;static object _obj = new object(); // 자물쇠 역할static void Thread_1(){ for (int i = 0; i &amp;lt; 100000; i++) { lock(_obj) { // Critical Section number++; } }}static void Thread_2(){ for (int i = 0; i &amp;lt; 100000; i++) { lock (_obj) { // Critical Section number--; } }}lock 내부 구현 역시 Monitor로 구현되어 있기 때문에 동작 방식은 비슷하다고 생각하면 된다.실제로 Monitor를 직접적으로 사용할 일은 별로 없을 것고 보통 위 lock을 많이 사용한다. 다만 동작 방식은 이해해두면 좋기 때문에 같이 알아두면 좋다." }, { "title": "[Blazor] SPA구조, Router", "url": "/posts/SPA%EA%B5%AC%EC%A1%B0Router/", "categories": "웹 서버, Blazor 입문", "tags": "Blazor, SPA, Rounter", "date": "2022-03-29 13:01:00 +0900", "snippet": "SPA(Single Page Application)SPA(Single Page Application)는 서버로부터 완전한 새로운 페이지를 불러오지 않고 현재의 페이지를 동적으로 다시 작성함으로써 사용자와 소통하는 웹 애플리케이션을 말한다.SPA이전의 전통적인 방식에서는 처음 웹홈페이지에 접속하면 서버에서는 그에 맞는 HTML 정보를 전달해준다. 그러고 다른 페이지에 들어간다거나 하면 서버에 요청해 또 그에 맞는 HTML 정보를 받는다. 그렇다보니 동일한 데이터도 계속 받게되는 일이 발생하게 된다.예를 들어 웹사이트에서 보통 다른 페이지로 이동할 때 상단 바 또는 사이드 메뉴는 바뀌지 않는 경우가 많은데 이러한 부분들도 매번 똑같은 데이터를 받고 Reload를 하는 것이다.그러나 SPA 방식에서는 처음 접속할때만 서버로부터 필요한 HTML 정보들을 받고 이후에는 AJAX를 통해 데이터만 요청하고 받아 클라이언트에서 렌더링하여 사용자에게 보여준다. 쉽게 말해 변하는 내용 부분만 따로 받고 렌더링해서 보여준다는 것이다. AJAX(Asynchronous Javascript And XML) - Javascript 비동기 통신, XML 데이터를 주고 받는 기술Blazor 구조HelloBlazorServer앞 포스트에서 Blazor Server 구조에 대해 코드를 따라가보는 방식으로 간단하게 살펴보았는데 이번엔 위 SPA 개념을 이해한채로 좀 더 자세히 뜯어보는 방식으로 살펴보겠다.위 SPA 개념에 따르면 어떤 틀이 있고 그 틀안에 내용만 계속 바뀐다는 것인데 Blazor Server 프로젝트를 생성해 그냥 실행시켜보면 중앙 컨텐츠 부분은 페이지 이동에 따라 계속 바뀌지만 위 옆 사이드 부분은 바뀌지 않는 것을 볼 수 있을 것이다.그렇다면 그 틀은 어디서 정의해주고 있는 것일까.결론부터 말하자면 Shared 폴더 안 MainLayout.razor 파일에서 정의해주고 있다.LayoutMainLayout.razor@inherits LayoutComponentBase&amp;lt;div class=&quot;sidebar&quot;&amp;gt; &amp;lt;NavMenu /&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div class=&quot;main&quot;&amp;gt; &amp;lt;div class=&quot;top-row px-4&quot;&amp;gt; &amp;lt;a href=&quot;https://docs.microsoft.com/aspnet/&quot; target=&quot;_blank&quot;&amp;gt;About&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;content px-4&quot;&amp;gt; @Body &amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;MainLayout.razor에 가보면 첫줄부터 이미 다른 Razor Component들과 다르게 LayoutComponentBase를 상속받고 있는 것을 볼 수 있다.상속받고 있는 LayoutComponentBase 이름만 봐도 Layout 관련 Component임을 짐작해볼 수 있을 것이다. LayoutComponentBase를 세부적으로 열어보면 아래와 같이 되어 있다.LayoutComponentBasenamespace Microsoft.AspNetCore.Components{ public abstract class LayoutComponentBase : ComponentBase { protected LayoutComponentBase(); [Parameter] public RenderFragment Body { get; set; } }}LayoutComponentBase 내부를 살펴보면 Parameter를 통해 RenderFragment형태로 Body를 받고 있는 것을 볼 수 있다. 그리고 다시 MainLayout.razor로 돌아가보면 @Body로 사용하고 있는 것을 볼 수 있다.여기까지를 통해 알 수 있는 것은 공통적인 Layout부분은 MainLayout.razor로 만들어 놓았고 그 안에 담길 컨텐츠부분은 Parameter로 받아 표현되고 있다는 것이다.참고로 당연히 다른 Layout을 만들어 볼수도 있다.Shared 폴더에 Razor Component를 새로 생성해보고 이름은 Layout2라고 지어보자. 그리고 내용은 일단 MainLayout.razor를 그대로 복사해오고 원래 Layout과 구분해주기 위해 About 문자 부분만 Layout2라고 수정해놓자.Layout2.razor@inherits LayoutComponentBase&amp;lt;div class=&quot;sidebar&quot;&amp;gt; &amp;lt;NavMenu /&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div class=&quot;main&quot;&amp;gt; &amp;lt;div class=&quot;top-row px-4&quot;&amp;gt; &amp;lt;a href=&quot;https://docs.microsoft.com/aspnet/&quot; target=&quot;_blank&quot;&amp;gt;Layout2&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;content px-4&quot;&amp;gt; @Body &amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;그 다음 Counter 페이지만 Layout2를 적용시켜보자. Counter.razor에 가서 아래와 같이 @layout Layout2 만 넣어주면 된다.Counter.razor@page &quot;/counter&quot;@layout Layout2&amp;lt;h1&amp;gt;Counter&amp;lt;/h1&amp;gt;&amp;lt;p&amp;gt;Current count: @currentCount&amp;lt;/p&amp;gt;&amp;lt;button class=&quot;btn btn-primary&quot; @onclick=&quot;IncrementCount&quot;&amp;gt;Click me&amp;lt;/button&amp;gt;@code { private int currentCount = 0; private void IncrementCount() { currentCount++; }}실행시켜보면 Counter 페이지만 Layout2로 적용된 것을 볼 수 있다. 그렇다면 나머지 다른 페이지들은 기본적으로 MainLayout을 적용받고 있다는 것인데 그에 대한 설정은 어디서 해주고 있는 것일까. 바로 App.razor에서 해주고 있다. App.razor에 가보면 DefaultLayout을 MainLayout으로 설정해주고 있는 것을 볼 수 있다.App.razor&amp;lt;Router AppAssembly=&quot;@typeof(Program).Assembly&quot;&amp;gt; &amp;lt;Found Context=&quot;routeData&quot;&amp;gt; &amp;lt;RouteView RouteData=&quot;@routeData&quot; DefaultLayout=&quot;@typeof(MainLayout)&quot; /&amp;gt; &amp;lt;/Found&amp;gt; &amp;lt;NotFound&amp;gt; &amp;lt;LayoutView Layout=&quot;@typeof(MainLayout)&quot;&amp;gt; &amp;lt;p&amp;gt;Sorry, there&#39;s nothing at this address.&amp;lt;/p&amp;gt; &amp;lt;/LayoutView&amp;gt; &amp;lt;/NotFound&amp;gt;&amp;lt;/Router&amp;gt;추가적으로 현재 프로젝트에 _Imports.razor 파일이 있을 것인데 Pages 폴더 안에 똑같은 이름으로 _Imports.razor를 생성하고 안에 @layout Layout2 을 넣은 뒤 실행시켜보면 모든 페이지가 Layout2로 적용된 것을 볼 수 있다._Imports.razor는 같은 폴더안에 있는 모든 Razor Component에게 다 적용되는 파일이라고 할 수 있다.이런식으로 DefaultLayout을 지정하지 않고도 Layout을 적용시킬 수 있다.여까지 Layout 부분에 대해 살펴보았다면 그 다음으로는 Rounter 부분에 대해 살펴보자.Rounter먼저 App.razor에 가보면 Router라는 것이 나오는데App.razor&amp;lt;Router AppAssembly=&quot;@typeof(Program).Assembly&quot;&amp;gt; &amp;lt;Found Context=&quot;routeData&quot;&amp;gt; &amp;lt;RouteView RouteData=&quot;@routeData&quot; DefaultLayout=&quot;@typeof(MainLayout)&quot; /&amp;gt; &amp;lt;/Found&amp;gt; &amp;lt;NotFound&amp;gt; &amp;lt;LayoutView Layout=&quot;@typeof(MainLayout)&quot;&amp;gt; &amp;lt;p&amp;gt;Sorry, there&#39;s nothing at this address.&amp;lt;/p&amp;gt; &amp;lt;/LayoutView&amp;gt; &amp;lt;/NotFound&amp;gt;&amp;lt;/Router&amp;gt;Routernamespace Microsoft.AspNetCore.Components.Routing{ public class Router : IComponent, IHandleAfterRender, IDisposable { public Router(); [Parameter] public IEnumerable&amp;lt;Assembly&amp;gt; AdditionalAssemblies { get; set; } [Parameter] public Assembly AppAssembly { get; set; } [Parameter] public RenderFragment&amp;lt;RouteData&amp;gt; Found { get; set; } [Parameter] public RenderFragment NotFound { get; set; } public void Attach(RenderHandle renderHandle); public void Dispose(); public Task SetParametersAsync(ParameterView parameters); }}이 Router를 세부적으로 열어보면 얘 또한 Component인 것을 알 수 있다. 또한 Found랑 NotFount에 대해 태그 형식으로 작성해 주었는데 이 또한 RenderFragment형식으로 받아 주고 있는 것을 알 수 있다.Router는 우리가 웹페이지 주소(URL)를 입력하면 해당 경로에 맞게 페이지를 찾아주는 역할을 한다. 그리고 페이지를 찾기 위해서는 각 페이지 마다 아래와 같이 경로를 지정해주어야 한다.@page &quot;/counter&quot;추가적으로 경로를 입력할 때 ‘/counter/55’ 이런식으로 인자를 넘겨줄 수도 있는데 이는 아래와 같이 받아 사용할 수 있다.Counter.razor@page &quot;/counter&quot;&amp;lt;!-- Route parameter --&amp;gt;@page &quot;/counter/{CurrentCount:int}&quot;&amp;lt;h1&amp;gt;Counter&amp;lt;/h1&amp;gt;&amp;lt;p&amp;gt;Current count: @CurrentCount&amp;lt;/p&amp;gt;&amp;lt;button class=&quot;btn btn-primary&quot; @onclick=&quot;IncrementCount&quot;&amp;gt;Click me&amp;lt;/button&amp;gt;@code { [Parameter] public int CurrentCount { get; set; } private void IncrementCount() { CurrentCount++; }}실행시켜 ‘/counter/57’ 이런식으로 주소를 입력해보면 Count가 57이 되어 있는 것을 볼 수 있을 것이다.여까지 Blazor 구조와 Layout 적용 방법, Routing까지 살펴보았다." }, { "title": "[Blazor] Dependency Injection", "url": "/posts/DependencyInjection/", "categories": "웹 서버, Blazor 입문", "tags": "Blazor, Dependency, Dependency Injection", "date": "2022-03-27 16:35:00 +0900", "snippet": "Dependency InjectionDependency Injection 줄여서 DI라고 하기도 하고, 우리말로는 의존성 주입이라고 하기도 한다.Dependency Injection을 제대로 이해하려면 먼저 Dependency(의존성)에 대해 이해해야한다.Dependency (의존성)그냥 “A가 B에게 의존한다.”라고 하면 크게 와닿지 않을 것이다. 의존한다라는 의미가 추상적이기 때문이다. 그러나 의존한다는 아래와 같이 정의해볼 수 있다. “B가 변하면 A에게 영향을 미친다.” 즉 B가 변할 때 A에게 영향을 미치면 A는 B에게 의존한다라고 할 수 있다.의존관계를 코드로 표현해보면 아래와 같다.FoodService.cspublic class Food{ public string Name { get; set; } public int Price { get; set; }}public class FoodService{ public List&amp;lt;Food&amp;gt; GetFoods() { List&amp;lt;Food&amp;gt; foods = new List&amp;lt;Food&amp;gt;() { new Food(){Name = &quot;Bibimbap&quot;, Price = 7000 }, new Food(){Name = &quot;Kimbap&quot;, Price = 3000 }, new Food(){Name = &quot;Bossam&quot;, Price = 9000 } }; return foods; }}Index.razor@page &quot;/&quot;@using BlazorApp.Data;&amp;lt;div&amp;gt; &amp;lt;!-- Food 목록 출력 --&amp;gt; @foreach(var food in _foodService.GetFoods()) { &amp;lt;div&amp;gt;@food.Name&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;@food.Price&amp;lt;/div&amp;gt; }&amp;lt;/div&amp;gt;@code{ // FoodService 객체 생성 FoodService _foodService = new FoodService();}우리가 식당 개점을 해본다고 생각하면서 보면 좀 더 이해하기 쉬울 것이다.Index.razor에서는 FoodService 객체를 생성해 Food 목록을 받아 출력해주고 있다. 여기서 만약 FoodService 클래스 내부가 바뀌거나 다른 FoodService가 생긴다거나 하면 Index.razor 또한 그에 맞게 수정해주어야 할 것이다. FoodService가 변하게 되면 Index.razor에게 영향을 미친다는 의미이다. 그렇기에 Index.razor는 FoodService에게 의존한다고 할 수 있다.이런식으로 직접적으로 연결되서 사용하는 경우에는 의존성이 강하다고 할 수 있다. 의존성이 강하면 그닥 좋지는 않다. 앞에서도 말했다싶이 FoodService가 수정되면 그에 맞게 Index.razor도 수정해주어야 한다. 지금은 코드가 간단해서 큰 문제는 아니겠지만 코드가 복잡할수록 유지보수가 힘들어 질 것이다.이 문제를 개선하려면 어떻게 해야할까.일단 interface를 사용해볼 수 있다.FoodService에 대한 interface를 만들고 각 클라이언트에서는 interface를 통해 FoodService를 사용하는 것이다.코드로 표현하면 아래와 같다.FoodService.cspublic class Food{ public string Name { get; set; } public int Price { get; set; }}// interface 만들기public interface IFoodService{ IEnumerable&amp;lt;Food&amp;gt; GetFoods();}public class FoodService : IFoodService{ public IEnumerable&amp;lt;Food&amp;gt; GetFoods() { List&amp;lt;Food&amp;gt; foods = new List&amp;lt;Food&amp;gt;() { new Food(){Name = &quot;Bibimbap&quot;, Price = 7000 }, new Food(){Name = &quot;Kimbap&quot;, Price = 3000 }, new Food(){Name = &quot;Bossam&quot;, Price = 9000 } }; return foods; }}Index.razor@page &quot;/&quot;@using BlazorApp.Data;&amp;lt;div&amp;gt; @foreach(var food in _foodService.GetFoods()) { &amp;lt;div&amp;gt;@food.Name&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;@food.Price&amp;lt;/div&amp;gt; }&amp;lt;/div&amp;gt;@code{ // interface로 객체 받기 IFoodService _foodService = new FoodService();}이렇게 했을 경우 FoodService를 사용하는 쪽에서는 interface를 통해 기능을 사용하면되고 FoodService 쪽에서는 interface에 맞게 기능을 구현하면 된다. 또한 새로운 FoodService를 만든다고 하더라도 interface에 맞게 구현하면 사용하는 쪽에서 큰 수정 없이 사용할 수 있기 때문에 의존성이 좀 약해졌다고 할 수 있다.예를 들어 FastFoodService라고 또다른 FoodService를 만든다고 해보자. interface에만 맞게 구현하면 Index.razor에서는 FoodService 이름만 바꾸어 사용할 수 있다.FoodService.cspublic class Food { public string Name { get; set; } public int Price { get; set; } } public interface IFoodService { IEnumerable&amp;lt;Food&amp;gt; GetFoods(); } public class FoodService : IFoodService { public IEnumerable&amp;lt;Food&amp;gt; GetFoods() { List&amp;lt;Food&amp;gt; foods = new List&amp;lt;Food&amp;gt;() { new Food(){Name = &quot;Bibimbap&quot;, Price = 7000 }, new Food(){Name = &quot;Kimbap&quot;, Price = 3000 }, new Food(){Name = &quot;Bossam&quot;, Price = 9000 } }; return foods; } } // 새로운 FoodService public class FastFoodService : IFoodService { public IEnumerable&amp;lt;Food&amp;gt; GetFoods() { List&amp;lt;Food&amp;gt; foods = new List&amp;lt;Food&amp;gt;() { new Food(){Name = &quot;Hamburger&quot;, Price = 500 }, new Food(){Name = &quot;Fries&quot;, Price = 2000 } }; return foods; } }Index.razor@page &quot;/&quot;@using BlazorApp.Data;&amp;lt;div&amp;gt; @foreach(var food in _foodService.GetFoods()) { &amp;lt;div&amp;gt;@food.Name&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;@food.Price&amp;lt;/div&amp;gt; }&amp;lt;/div&amp;gt;@code{ // FoodService 이름만 수정 IFoodService _foodService = new FastFoodService();}Interface를 사용함으로써 Service를 사용하는 쪽에서는 Interface에 정의되어 있는 기능대로만 사용하면 되니 수정되더라도 큰 위화감 없이 사용할 수 있다.하지만 아직 객체를 직접 생성해서 사용한다고 있기에 의존성 문제를 완전 해결해주지는 못하고 있다. 왜냐하면 어떤 Service를 사용할 것인가는 결국 사용하는 쪽에서 결정해주고 있고 Service가 바뀌거나 하면 어짜피 사용하는 쪽에서도 수정을 해줘야하기 때문이다. 또한 다른곳에서도 사용한다면 거기서도 새로운 객체를 생성해서 사용해야할텐데 동일한 Service지만 여러개의 객체가 생성되는 꼴이다.이때 사용해볼 수 있는 것이 Dependency Injection이다.Dependency InjectionDependency Injection을 우리말로 번역하면 의존성 주입이라고 할 수 이다.지금까지는 Service를 사용하는 쪽에서 내부적으로 어떤 Service를 사용할지 결정해주었다면 Dependency Injection은 외부에서 결정하여 주입해주는 방식이다.ASP.NET Core에서는 Dependency Injection을 아래와 같이 사용해볼 수 있다.Startup.cs에 가서 ConfigureServices 함수안에 Service를 추가해주기만 하면 된다.Startup.cspublic class Startup{ // ... public void ConfigureServices(IServiceCollection services) { services.AddRazorPages(); services.AddServerSideBlazor(); services.AddSingleton&amp;lt;WeatherForecastService&amp;gt;(); // Service 등록 (Dependency Injection) services.AddSingleton&amp;lt;IFoodService, FastFoodService&amp;gt;(); } // ...}그리고 사용하는 쪽에서는 아래와 같이 선언해주고 사용하면된다.Index.razor@page &quot;/&quot;@using BlazorApp.Data;&amp;lt;!-- FoodService를 주입받기 (Dependency Injection) --&amp;gt;@inject IFoodService foodService;&amp;lt;div&amp;gt; @foreach(var food in foodService.GetFoods()) { &amp;lt;div&amp;gt;@food.Name&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;@food.Price&amp;lt;/div&amp;gt; }&amp;lt;/div&amp;gt;@code{}이전까진 사용하는 쪽에서 어떤 FoodService를 사용할지 결정하고 객체를 따로 생성해서 사용하였다면 지금은 Startup.cs에서 어떤 FoodService를 할지 일괄적으로 결정해주고 해당 Service를 사용하는 쪽에 주입해주고 있다. 그렇기에 만약 다른 FoodService를 적용시키고 싶다면 그냥 Startup.cs 내에 ConfigureServices만 수정해주면 된다.또한 하나 더 추가적인 특징으로는 Dependency Injection을 사용할 때 다른 Service들끼리도 자동으로 연결시켜 줄 수 있다는 것이다.예를 들어 위 예제에서 결제서비스로 PaymentService를 만든다고 하였을 때 어떤 FoodService를 사용하고 있는지 알기 위해 아래와 같이 생성자에서 FoodService를 인자로 받아볼 수 있을 것이다.public class PaymentService{ IFoodService _service; public PaymentService(IFoodService service) { _service = service; } // 기능 구현}이러할때 Startup.cs에 똑같이 등록해 놓으면 자동으로 연결시켜 준다. 우리가 따로 인자를 넘겨주지 않아도 알아서 생성자를 호출할 때 현재 생성해놓은 FoodService를 인자로 넘겨준다는 것이다.Startup.cspublic class Startup{ // ... public void ConfigureServices(IServiceCollection services) { services.AddRazorPages(); services.AddServerSideBlazor(); services.AddSingleton&amp;lt;WeatherForecastService&amp;gt;(); services.AddSingleton&amp;lt;IFoodService, FastFoodService&amp;gt;(); // 생성될때 자동으로 알아서 FoodService를 인자로 넘겨줌 services.AddSingleton&amp;lt;PaymentService&amp;gt;(); } // ...}SingletonService, TransientService, ScopedService마지막으로 Dependency Injection을 사용할 때 3가지 모드가 있다. SingletonService TransientService ScopedService3가지 모드 모두 Dependency Injection이지만 수명주기에 차이가 있다.테스트를 위해 아래와 같이 3가지의 Service를 만들어 보겠다.// Guid는 유니크한 ID를 생성하고 관리할 때 유용한 클래스이다.public class SingletonService : IDisposable{ public Guid ID { get; set; } public SingletonService() { ID = Guid.NewGuid(); } public void Dispose() { Console.WriteLine(&quot;SingletonService Disposed&quot;); }}public class TransientService : IDisposable{ public Guid ID { get; set; } public TransientService() { ID = Guid.NewGuid(); } public void Dispose() { Console.WriteLine(&quot;TransientService Disposed&quot;); }}public class ScopedService : IDisposable{ public Guid ID { get; set; } public ScopedService() { ID = Guid.NewGuid(); } public void Dispose() { Console.WriteLine(&quot;ScopedService Disposed&quot;); }}그리고 Startup.cs에 각자 다른 모드로 Dependency Injection을 해주고 ID를 페이지에 출력하도록 해보자.Startup.cspublic class Startup{ // ... public void ConfigureServices(IServiceCollection services) { services.AddRazorPages(); services.AddServerSideBlazor(); services.AddSingleton&amp;lt;WeatherForecastService&amp;gt;(); // 3가지 모드 services.AddSingleton&amp;lt;SingletonService&amp;gt;(); services.AddTransient&amp;lt;TransientService&amp;gt;(); services.AddScoped&amp;lt;ScopedService&amp;gt;(); } // ...}Index.razor@page &quot;/&quot;@using BlazorApp.Data;@inject SingletonService singleton;@inject TransientService transient;@inject ScopedService scoped;&amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;Singleton&amp;lt;/h1&amp;gt; Guid: @singleton.ID &amp;lt;h1&amp;gt;Transient&amp;lt;/h1&amp;gt; Guid: @transient.ID &amp;lt;h1&amp;gt;Scoped&amp;lt;/h1&amp;gt; Guid: @scoped.ID&amp;lt;/div&amp;gt;@code{}실행시켜 페이지도 왔다갔다해보고 새로고침도 해보면 수명주기를 확인해볼 수 있다.페이지를 왔다갔다 해보면 Transient의 ID만 바뀌고, 페이지를 새로고침 해보면 Transient와 Scoped의 ID가 바뀌는 것을 볼 수 있다.Singleton, Transient, Scoped 수명주기 테스트 화면위 결과를 정리하자면 Singleton의 경우 서버를 처음 실행시킬때 생성된 이후로 변함이 없고, Transient는 매번 요청할 때마다 변하고, Scoped는 처음 접속하여 요청할 때만 변한다.따라서 3가지 모드의 수명주기를 비교하자면 아래와 같다.수명주기: Singleton &amp;gt; Scoped &amp;gt; Transient위 차이를 알고 상황에 맞게 골라 Dependency Injection을 사용하면 된다." }, { "title": "[OPIc] Self-introduction", "url": "/posts/OPIc%EC%9E%90%EA%B8%B0%EC%86%8C%EA%B0%9C/", "categories": "English, OPIc", "tags": "OPIc", "date": "2022-03-17 22:46:00 +0900", "snippet": "Q. Let’s start the interview now. Tell me a little about yourself.Hello. My name is Euichan, and I am 24 years old. I am currently looking for a job. My major was software. I chose this major because I would like to have a job in this field. I live with my brother in a Suwon. This is because my hometown is Changwon, so I can’t live with my family. My parents live in Changwon. Sometimes I go to my hometown to see my parents. I think I am a social person. I really enjoy hanging out with my friends. When I have free time, I like to play games with my friends." }, { "title": "[Blazor] Templated Component", "url": "/posts/TemplatedComponent/", "categories": "웹 서버, Blazor 입문", "tags": "Blazor, Templated Component, RenderFragment", "date": "2022-03-17 14:47:00 +0900", "snippet": "Templated ComponentBlazor Templated Component는 하나 이상의 UI 템플릿을 매개 변수로 허용한 다음, 이 매개 변수를 구성 요소 렌더링 논리의 일부로 사용할 수 있는 구성 요소이다.쉽게 말해 어떤 UI 구조를 템플릿화하여 재사용이 용이하도록 만드는 것을 말한다.예를 들어 아래와 같은 페이지에서 테이블 형식으로 표현된 UI 구조를 다른 곳에서도 사용하고 싶다면 매번 코드 자체를 복사하여 사용해도 되지만 저 테이블 구조를 템플릿화하여 어디에서든지 저 구조를 사용할 수 있게 한다면 좀 더 효율적일 것이다.테이블 구조Templated Component 실습 (FetchData.razor)Blazor 프로젝트를 생성하면 기본적으로 생성되는 FetchData.razor 예제를 가지고 실습을 해보자.FetchData.razor에서 테이블 부분을 다른 곳에서도 사용할 수 있도록 Templated Component로 만들어 볼 것이다.먼저 ‘새 항목 추가 &amp;gt; Razor 구성 요소’를 선택해 TableTemplate.razor를 생성해보자.다음 코드를 작성하기 전에 잠깐 알아야 하는 것이 있어 설명하자면 Templated Component에서는 RenderFragment 꼭 사용하게 된다. RenderFragment는 쉽게 말해 HTML 태그 등이 포함되어 있는 UI 컨텐츠를 인자로 받을 수 있게 하는 매개변수 형태라고 생각하면 된다.코드를 통해 간단하게 사용법을 보여드리자면 TableTemplate.razor&amp;lt;h3&amp;gt;TableTemplate&amp;lt;/h3&amp;gt;&amp;lt;table class=&quot;table&quot;&amp;gt; &amp;lt;thead&amp;gt; &amp;lt;tr&amp;gt; @Header &amp;lt;/tr&amp;gt; &amp;lt;/thead&amp;gt;&amp;lt;/table&amp;gt;@code { // Parameter로 UI 컨텐츠 받기 [Parameter] public RenderFragment Header { get; set; }}FetchData.razor...&amp;lt;!-- Header 정보를 인자로 넘기기 --&amp;gt;&amp;lt;TableTemplate&amp;gt; &amp;lt;Header&amp;gt; &amp;lt;th&amp;gt;Date&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;Temp. (C)&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;Temp. (F)&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;Summary&amp;lt;/th&amp;gt; &amp;lt;/Header&amp;gt;&amp;lt;/TableTemplate&amp;gt;...데이터를 받아 사용하는 쪽에서는 Parameter로 RenderFragment형 매개변수를 선언하면 되고, 데이터를 넘기는 쪽에서는 태그 형식으로 넘겨주면 된다.그럼 나머지 부분들도 작성해보자.TableTemplate.razor@using BlazorApp.Data;&amp;lt;!-- type도 Parameter로 받아 사용하고 있다. --&amp;gt;@typeparam TItem&amp;lt;h3&amp;gt;TableTemplate&amp;lt;/h3&amp;gt;&amp;lt;table class=&quot;table&quot;&amp;gt; &amp;lt;thead&amp;gt; &amp;lt;tr&amp;gt; @Header &amp;lt;!-- Parameter로 받은 RenderFragment 사용 --&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/thead&amp;gt; &amp;lt;tbody&amp;gt; @foreach (var item in Items) { &amp;lt;tr&amp;gt; @Row(item) &amp;lt;!-- Parameter로 받은 RenderFragment 사용 --&amp;gt; &amp;lt;/tr&amp;gt; } &amp;lt;/tbody&amp;gt;&amp;lt;/table&amp;gt;@code { [Parameter] public RenderFragment Header { get; set; } // 인자가 있는 형태의 RenderFragment [Parameter] public RenderFragment&amp;lt;TItem&amp;gt; Row { get; set; } // UI에 표시할 데이터 [Parameter] public IReadOnlyList&amp;lt;TItem&amp;gt; Items { get; set; }}FetchData.razor@page &quot;/fetchdata&quot;@using BlazorApp.Data@inject WeatherForecastService ForecastService&amp;lt;h1&amp;gt;Weather forecast&amp;lt;/h1&amp;gt;&amp;lt;p&amp;gt;This component demonstrates fetching data from a service.&amp;lt;/p&amp;gt;@if (forecasts == null){ &amp;lt;p&amp;gt;&amp;lt;em&amp;gt;Loading...&amp;lt;/em&amp;gt;&amp;lt;/p&amp;gt;}else{ &amp;lt;!-- TableTemplate 사용 --&amp;gt; &amp;lt;!-- UI로 표시할 데이터와 type을 인자로 넘겨주고 있음 --&amp;gt; &amp;lt;TableTemplate Items=&quot;forecasts&quot; TItem=&quot;WeatherForecast&quot;&amp;gt; &amp;lt;!-- RenderFragment --&amp;gt; &amp;lt;Header&amp;gt; &amp;lt;th&amp;gt;Date&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;Temp. (C)&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;Temp. (F)&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;Summary&amp;lt;/th&amp;gt; &amp;lt;/Header&amp;gt; &amp;lt;!-- 인자가 있는 형태의 RenderFragment --&amp;gt; &amp;lt;!-- Context=&quot;인자로 받을 매개변수 이름&quot;(아무렇게 지어도 됨) --&amp;gt; &amp;lt;Row Context=&quot;forecast&quot;&amp;gt; &amp;lt;td&amp;gt;@forecast.Date.ToShortDateString()&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;@forecast.TemperatureC&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;@forecast.TemperatureF&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;@forecast.Summary&amp;lt;/td&amp;gt; &amp;lt;/Row&amp;gt; &amp;lt;/TableTemplate&amp;gt;}@code { private WeatherForecast[] forecasts; protected override async Task OnInitializedAsync() { forecasts = await ForecastService.GetForecastAsync(DateTime.Now); }}주석으로 표시한 부분을 유심히 보면 된다.실행시켜보면 정상적으로 테이블이 생성돼 표현된 것을 볼 수 있다.TableTemplate 사용 모습이런식으로 자주 사용하게 될 것같은 UI구조를 Templated Component로 만들면 동일한 UI구조를 다른 곳에서도 쉽게 사용할 수 있으며 코드 재사용률도 높일 수 있다." }, { "title": "[Blazor] Cascading Parameter", "url": "/posts/CascadingParameter/", "categories": "웹 서버, Blazor 입문", "tags": "Blazor, Parameter, Cascading Parameter", "date": "2022-03-15 14:28:00 +0900", "snippet": "Cascading ParameterCascading Parameter는 상위 Component에서 원하는 수의 하위 Component들에게 데이터를 전달할 수 있는 기능이다.쉽게 말해 일반적인 Parameter의 경우 데이터를 전달해줄때 Component마다 개별적으로 전달해주어야 하지만 Cascading Parameter의 경우 폭포(cascade)처럼 한번에 하위 Component들에게 데이터를 전달해 줄 수 있다.예를 들어 웹 페이지에서 테마 색상을 바꿀 수 있는 옵션을 추가한다고 하였을 때 상위 Component에서 색상을 바꾸게 되면 하위 Component들도 똑같이 색상 정보를 받아 테마 색을 바꿔야 할 것이다. 이때 일반적인 Parameter로 색상 정보를 전달할 경우 아래와 같이 하위 Component 태그마다 일일이 전달해 주어야 할 것이다.&amp;lt;component1 Color=&quot;_selectedColor&quot;&amp;gt;&amp;lt;/component1&amp;gt;&amp;lt;component2 Color=&quot;_selectedColor&quot;&amp;gt;&amp;lt;/component2&amp;gt;&amp;lt;component3 Color=&quot;_selectedColor&quot;&amp;gt;&amp;lt;/component3&amp;gt;...하지만 Cascading Parameter를 사용할 경우 아래와 같이 하위 Component들에게 한번에 전달해 줄 수 있다.&amp;lt;CascadingValue Name=&quot;ThemeColor&quot; Value=&quot;_selectedColor&quot;&amp;gt; &amp;lt;component1&amp;gt;&amp;lt;/component1&amp;gt; &amp;lt;component2&amp;gt;&amp;lt;/component2&amp;gt; &amp;lt;component3&amp;gt;&amp;lt;/component3&amp;gt; ...&amp;lt;/CascadingValue&amp;gt;Cascading Parameter 사용법&amp;lt;CascadingValue&amp;gt;&amp;lt;CascadingValue Name=&quot;ThemeColor&quot; Value=&quot;_selectedColor&quot;&amp;gt; &amp;lt;!-- Component --&amp;gt; &amp;lt;!-- Component --&amp;gt; &amp;lt;!-- Component --&amp;gt;&amp;lt;/CascadingValue&amp;gt;@code { string _selectedColor = &quot;Green&quot;;}값을 전달할 때는 &amp;lt;CascadingValue&amp;gt; 태그를 사용해 CascadingValue 이름과 전달할 Value를 지정한다.[CascadingParameter]@code { [CascadingParameter(Name = &quot;ThemeColor&quot;)] string _color { get; set; }}값을 받을 때는 Parameter로 받을 변수 위에 [CascadingParameter]를 붙이고 받을 CascadingValue 이름을 지정한다. Parameter로 받을 변수는 프로퍼티로 선언해야 한다.Cascading Parameter 실습 (User 관리 페이지)이전 포스트에서 구현해놓은 User 관리 페이지에다 테마 색상 옵션을 추가해 간단하게 User 이름 색상만 바꾸어 보자.이전 포스트User.razor@page &quot;/user&quot;@using BlazorApp.Data;&amp;lt;h3&amp;gt;Online Users&amp;lt;/h3&amp;gt;&amp;lt;!-- 테마 색상 선택 UI--&amp;gt;&amp;lt;label&amp;gt;Theme Color:&amp;lt;/label&amp;gt;&amp;lt;select class=&quot;form-control&quot; @bind=&quot;_selectedColor&quot;&amp;gt; @foreach(var option in _options) { &amp;lt;option value=&quot;@option&quot;&amp;gt; @option &amp;lt;/option&amp;gt; }&amp;lt;/select&amp;gt;&amp;lt;!-- CascadingValue를 사용해 색상 정보 전달하기 --&amp;gt;&amp;lt;CascadingValue Name=&quot;ThemeColor&quot; Value=&quot;_selectedColor&quot;&amp;gt; &amp;lt;ShowUser Users=&quot;_users&quot; CallbackTest=&quot;CallbackTestFunc&quot; @ref=&quot;_showUser&quot;&amp;gt;&amp;lt;/ShowUser&amp;gt;&amp;lt;/CascadingValue&amp;gt;&amp;lt;br /&amp;gt;&amp;lt;div class=&quot;container&quot;&amp;gt; &amp;lt;div class=&quot;row&quot;&amp;gt; &amp;lt;div class=&quot;col&quot;&amp;gt; &amp;lt;input class=&quot;form-control&quot; placeholder=&quot;Add User&quot; @bind-value=&quot;_inputName&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;col&quot;&amp;gt; &amp;lt;button class=&quot;btn btn-primary&quot; type=&quot;button&quot; @onclick=&quot;AddUser&quot;&amp;gt;Add a User&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;@code { // 테마 색상 string _selectedColor = &quot;Green&quot;; List&amp;lt;string&amp;gt; _options = new List&amp;lt;string&amp;gt;() { &quot;Green&quot;, &quot;Red&quot;, &quot;Blue&quot; }; List&amp;lt;UserData&amp;gt; _users = new List&amp;lt;UserData&amp;gt;(); ShowUser _showUser; string _inputName; void AddUser() { _showUser.AddUser(new UserData() { Name = _inputName }); _inputName = &quot;&quot;; } void CallbackTestFunc() { _inputName = &quot;CallbackTest&quot;; //StateHasChanged(); }}ShowUser.razor@using BlazorApp.Data;&amp;lt;p&amp;gt; Users: &amp;lt;b&amp;gt;@Users.Count()&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;br /&amp;gt;&amp;lt;ul class=&quot;list-group&quot;&amp;gt; @foreach (UserData user in Users) { &amp;lt;li @key=&quot;user&quot; class=&quot;list-group-item&quot;&amp;gt; &amp;lt;button type=&quot;button&quot; class=&quot;btn btn-link&quot; @onclick=&quot;(() =&amp;gt; KickUser(user))&quot;&amp;gt;[Kick]&amp;lt;/button&amp;gt; &amp;lt;!-- 라벨에다 색상 적용 --&amp;gt; &amp;lt;label style=&quot;color:@_color&quot;&amp;gt;@user.Name&amp;lt;/label&amp;gt; &amp;lt;/li&amp;gt; }&amp;lt;/ul&amp;gt;@code { // Cascading Parameter로 색상 정보 받기 [CascadingParameter(Name = &quot;ThemeColor&quot;)] string _color { get; set; } [Parameter] public List&amp;lt;UserData&amp;gt; Users { get; set; } [Parameter] public EventCallback CallbackTest { get; set; } protected override void OnInitialized() { Users.Add(new UserData() { Name = &quot;define_chan&quot; }); Users.Add(new UserData() { Name = &quot;Rookiss&quot; }); Users.Add(new UserData() { Name = &quot;Dongglee&quot; }); } public void AddUser(UserData user) { Users.Add(user); } public void KickUser(UserData user) { Users.Remove(user); CallbackTest.InvokeAsync(null); }}주석부분을 유심히 살펴보면 이해가 될것이다.User.razor에서는 Cascading Parameter를 통해 테마 색상 정보를 ShowUser.razor에게 전달하고 있고 ShowUser.razor에서는 색상 정보를 받아 Label 색상에 적용시키고 있다.실행시켜보면 색상을 선택할 때마다 User 이름들의 색이 바뀌는 것을 볼 수 있다.Theme Color" }, { "title": "[Blazor] Parameter, Ref, EventCallback", "url": "/posts/ParameterRefEventCallback/", "categories": "웹 서버, Blazor 입문", "tags": "Blazor, Parameter, Ref, EventCallback", "date": "2022-03-14 15:01:00 +0900", "snippet": "Component 분리Blazor에서는 Component 단위로 관리한다. Blazor에서의 Component를 Razor Component라고 부르며 확장자는 .razor이다. Component 단위로 분리하여 관리하면 코드 재사용률을 높일 수 있으며, 부품 조립하듯이 Component들을 조립하는 식으로 웹 페이지를 구성할 수 있다.앞에서 만들어본 User 관리 페이지를 보면 User 관리 페이지 User 목록을 보여주는 부분은 다른 곳에서도 사용할 수 있다. 다른 곳에서도 사용하는 방법은 코드를 그대로 복사 붙여넣기 방법도 있겠지만 User 목록을 보여주는 부분을 부품화하여 사용하고 싶은 곳 어디든 가져와 붙일 수 있다면 편할 것이다.그렇다면 User 목록을 보여주는 부분을 따로 꺼내 Component를 분리해보자.Pages 폴더에 ‘새 항목 추가 &amp;gt; Razor 구성 요소’를 선택해 ShowUser.razor를 생성한다. 그리고 User 목록을 보여주는 부분만 잘라내 ShowUser.razor에 붙여넣는다.ShowUser.razor&amp;lt;p&amp;gt; Users: &amp;lt;b&amp;gt;@_users.Count()&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;br /&amp;gt;&amp;lt;ul class=&quot;list-group&quot;&amp;gt; @foreach (UserData user in _users) { &amp;lt;li @key=&quot;user&quot; class=&quot;list-group-item&quot;&amp;gt; &amp;lt;button type=&quot;button&quot; class=&quot;btn btn-link&quot; @onclick=&quot;(() =&amp;gt; KickUser(user))&quot;&amp;gt;[Kick]&amp;lt;/button&amp;gt; &amp;lt;label&amp;gt;@user.Name&amp;lt;/label&amp;gt; &amp;lt;/li&amp;gt; }&amp;lt;/ul&amp;gt;@code {}그 다음 User.razor에서 ShowUser.razor를 사용하는 방법은 간단하다. &amp;lt;ShowUser&amp;gt;&amp;lt;/ShowUser&amp;gt; 이런식으로 태그를 넣으면 된다.User.razor@page &quot;/user&quot;@using BlazorApp.Data;&amp;lt;h3&amp;gt;Online Users&amp;lt;/h3&amp;gt;&amp;lt;!-- ShowUser 붙여넣기 --&amp;gt;&amp;lt;ShowUser&amp;gt;&amp;lt;/ShowUser&amp;gt;&amp;lt;br /&amp;gt;&amp;lt;div class=&quot;container&quot;&amp;gt; &amp;lt;div class=&quot;row&quot;&amp;gt; &amp;lt;div class=&quot;col&quot;&amp;gt; &amp;lt;input class=&quot;form-control&quot; placeholder=&quot;Add User&quot; @bind-value=&quot;_inputName&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;col&quot;&amp;gt; &amp;lt;button class=&quot;btn btn-primary&quot; type=&quot;button&quot; @onclick=&quot;AddUser&quot;&amp;gt;Add a User&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;@code { List&amp;lt;UserData&amp;gt; _users = new List&amp;lt;UserData&amp;gt;(); string _inputName; protected override void OnInitialized() { _users.Add(new UserData() { Name = &quot;define_chan&quot; }); _users.Add(new UserData() { Name = &quot;Rookiss&quot; }); _users.Add(new UserData() { Name = &quot;Dongglee&quot; }); } void AddUser() { _users.Add(new UserData() { Name = _inputName }); _inputName = &quot;&quot;; } void KickUser(UserData user) { _users.Remove(user); }}다만 이렇게 했을 때 문제가 발생한다. 첫 번째로 _users 라는 데이터를 둘다 사용하려고 하고 있다는 점이다. _users 라는 데이터를 공유할 수 있다면 좋을텐데 이때 사용할 수 있는 방법이 Parameter이다.ParameterRazor Component를 불러올때 함수를 호출하는 것처럼 Parameter를 통해 데이터를 전달해 줄 수 있다.ShowUser.razor에서는 Parameter를 통해 전달받을 변수를 선언해주고 User.razor에서는 ShowUser.razor를 부를 때 Parameter로 데이터를 넘겨준다.ShowUser.razor@using BlazorApp.Data;&amp;lt;p&amp;gt; Users: &amp;lt;b&amp;gt;@Users.Count()&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;br /&amp;gt;&amp;lt;ul class=&quot;list-group&quot;&amp;gt; @foreach (UserData user in Users) { &amp;lt;li @key=&quot;user&quot; class=&quot;list-group-item&quot;&amp;gt; &amp;lt;!--&amp;lt;button type=&quot;button&quot; class=&quot;btn btn-link&quot; @onclick=&quot;(() =&amp;gt; KickUser(user))&quot;&amp;gt;[Kick]&amp;lt;/button&amp;gt;--&amp;gt; &amp;lt;label&amp;gt;@user.Name&amp;lt;/label&amp;gt; &amp;lt;/li&amp;gt; }&amp;lt;/ul&amp;gt;@code { // Parameter로 받을 변수 선언 [Parameter] public List&amp;lt;UserData&amp;gt; Users { get; set; }}참고로 [Parameter]로 지정해주려면 프로퍼티 형식으로 선언해주어야 한다. 또한 UserData를 사용하기 위해 맨 위에 @using BlazorApp.Data;를 선언해주고 있다.User.razor@page &quot;/user&quot;@using BlazorApp.Data;&amp;lt;h3&amp;gt;Online Users&amp;lt;/h3&amp;gt;&amp;lt;!-- ShowUser 붙여넣기 Parameter로 _users 전달 --&amp;gt;&amp;lt;ShowUser Users=&quot;_users&quot;&amp;gt;&amp;lt;/ShowUser&amp;gt;&amp;lt;br /&amp;gt;&amp;lt;div class=&quot;container&quot;&amp;gt; &amp;lt;div class=&quot;row&quot;&amp;gt; &amp;lt;div class=&quot;col&quot;&amp;gt; &amp;lt;input class=&quot;form-control&quot; placeholder=&quot;Add User&quot; @bind-value=&quot;_inputName&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;col&quot;&amp;gt; &amp;lt;button class=&quot;btn btn-primary&quot; type=&quot;button&quot; @onclick=&quot;AddUser&quot;&amp;gt;Add a User&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;@code { List&amp;lt;UserData&amp;gt; _users = new List&amp;lt;UserData&amp;gt;(); string _inputName; protected override void OnInitialized() { _users.Add(new UserData() { Name = &quot;define_chan&quot; }); _users.Add(new UserData() { Name = &quot;Rookiss&quot; }); _users.Add(new UserData() { Name = &quot;Dongglee&quot; }); } void AddUser() { _users.Add(new UserData() { Name = _inputName }); _inputName = &quot;&quot;; } void KickUser(UserData user) { _users.Remove(user); }}Parameter로 넘겨줄 때는&amp;lt;!-- ShowUser 붙여넣기 Parameter로 _users 전달 --&amp;gt;&amp;lt;ShowUser Users=&quot;_users&quot;&amp;gt;&amp;lt;/ShowUser&amp;gt;이런 형식으로 전달해주면 된다.위와 같이 코드를 수정하였다면 실행이 잘 되는 것을 볼 수 있다.Parameter다음으로 현재 테스트를 위해 ShowUser.razor에서 [Kick] 버튼 부분을 주석처리하였는데 [Kick] 버튼을 사용하려면 ShowUser.razor에다 KickUser() 함수를 정의해야한다. 만약 User.razor에서 KickUser 기능을 사용하고 싶다면 ShowUser.razor 내에 KickUser 함수를 호출할 수 있어야 할 것이다. 이때 @ref를 사용하면 다른 Razor Component에 있는 함수들도 사용할 수 있다.@ref먼저 User 목록에 대해서는 ShowUser.razor에서 관리하는 것이 좋아보이니 ShowUser.razor에 AddUser, KickUser 함수 등을 정의해놓자.그 다음 User.razor에서 ShowUser.razor에 정의되어 있는 AddUser를 사용해보자.ShowUser.razor@using BlazorApp.Data;&amp;lt;p&amp;gt; Users: &amp;lt;b&amp;gt;@Users.Count()&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;br /&amp;gt;&amp;lt;ul class=&quot;list-group&quot;&amp;gt; @foreach (UserData user in Users) { &amp;lt;li @key=&quot;user&quot; class=&quot;list-group-item&quot;&amp;gt; &amp;lt;button type=&quot;button&quot; class=&quot;btn btn-link&quot; @onclick=&quot;(() =&amp;gt; KickUser(user))&quot;&amp;gt;[Kick]&amp;lt;/button&amp;gt; &amp;lt;label&amp;gt;@user.Name&amp;lt;/label&amp;gt; &amp;lt;/li&amp;gt; }&amp;lt;/ul&amp;gt;@code { [Parameter] public List&amp;lt;UserData&amp;gt; Users { get; set; } protected override void OnInitialized() { Users.Add(new UserData() { Name = &quot;define_chan&quot; }); Users.Add(new UserData() { Name = &quot;Rookiss&quot; }); Users.Add(new UserData() { Name = &quot;Dongglee&quot; }); } public void AddUser(UserData user) { Users.Add(user); } public void KickUser(UserData user) { Users.Remove(user); }}User.razor@page &quot;/user&quot;@using BlazorApp.Data;&amp;lt;h3&amp;gt;Online Users&amp;lt;/h3&amp;gt;&amp;lt;!-- ShowUser 붙여넣기 _showUser와도 연동--&amp;gt;&amp;lt;ShowUser Users=&quot;_users&quot; @ref=&quot;_showUser&quot;&amp;gt;&amp;lt;/ShowUser&amp;gt;&amp;lt;br /&amp;gt;&amp;lt;div class=&quot;container&quot;&amp;gt; &amp;lt;div class=&quot;row&quot;&amp;gt; &amp;lt;div class=&quot;col&quot;&amp;gt; &amp;lt;input class=&quot;form-control&quot; placeholder=&quot;Add User&quot; @bind-value=&quot;_inputName&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;col&quot;&amp;gt; &amp;lt;button class=&quot;btn btn-primary&quot; type=&quot;button&quot; @onclick=&quot;AddUser&quot;&amp;gt;Add a User&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;@code { List&amp;lt;UserData&amp;gt; _users = new List&amp;lt;UserData&amp;gt;(); ShowUser _showUser; string _inputName; void AddUser() { // ShowUser 내 AddUser 함수 호출 _showUser.AddUser(new UserData() { Name = _inputName }); _inputName = &quot;&quot;; }}실행시켜보면 Add a User와 Kick 기능이 잘 동작하는 것을 볼 수 있다.마지막으로 지금은 부모 Component 쪽에서 자식 Component 쪽 함수를 사용하고 있는데 반대로도 가능하다. 새로운 기능은 아니고 아까 Parameter 기능과 C#에서의 델리게이트를 활용한 방법이다.EventCallback부모 Component 쪽에서 Parameter로 함수를 전달하면 자식 Component 쪽에서 Callback 형식으로 호출이 가능하다.간단하게 테스트를 해보자.ShowUser.razor에서 델리게이트 형식으로 Parameter를 선언해놓고 KickUser()가 실행되었을 때 호출해주자.ShowUser.razor@using BlazorApp.Data;&amp;lt;p&amp;gt; Users: &amp;lt;b&amp;gt;@Users.Count()&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;br /&amp;gt;&amp;lt;ul class=&quot;list-group&quot;&amp;gt; @foreach (UserData user in Users) { &amp;lt;li @key=&quot;user&quot; class=&quot;list-group-item&quot;&amp;gt; &amp;lt;button type=&quot;button&quot; class=&quot;btn btn-link&quot; @onclick=&quot;(() =&amp;gt; KickUser(user))&quot;&amp;gt;[Kick]&amp;lt;/button&amp;gt; &amp;lt;label&amp;gt;@user.Name&amp;lt;/label&amp;gt; &amp;lt;/li&amp;gt; }&amp;lt;/ul&amp;gt;@code { [Parameter] public List&amp;lt;UserData&amp;gt; Users { get; set; } // 함수를 받을 Parameter 추가 [Parameter] public Action CallbackTest { get; set; } protected override void OnInitialized() { Users.Add(new UserData() { Name = &quot;define_chan&quot; }); Users.Add(new UserData() { Name = &quot;Rookiss&quot; }); Users.Add(new UserData() { Name = &quot;Dongglee&quot; }); } public void AddUser(UserData user) { Users.Add(user); } public void KickUser(UserData user) { Users.Remove(user); CallbackTest.Invoke(); // Parameter로 받은 함수 호출 }}User.razor@page &quot;/user&quot;@using BlazorApp.Data;&amp;lt;h3&amp;gt;Online Users&amp;lt;/h3&amp;gt;&amp;lt;!-- CallbackTestFunc도 Parameter로 전달 --&amp;gt;&amp;lt;ShowUser Users=&quot;_users&quot; CallbackTest=&quot;CallbackTestFunc&quot; @ref=&quot;_showUser&quot;&amp;gt;&amp;lt;/ShowUser&amp;gt;&amp;lt;br /&amp;gt;&amp;lt;div class=&quot;container&quot;&amp;gt; &amp;lt;div class=&quot;row&quot;&amp;gt; &amp;lt;div class=&quot;col&quot;&amp;gt; &amp;lt;input class=&quot;form-control&quot; placeholder=&quot;Add User&quot; @bind-value=&quot;_inputName&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;col&quot;&amp;gt; &amp;lt;button class=&quot;btn btn-primary&quot; type=&quot;button&quot; @onclick=&quot;AddUser&quot;&amp;gt;Add a User&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;@code { List&amp;lt;UserData&amp;gt; _users = new List&amp;lt;UserData&amp;gt;(); ShowUser _showUser; string _inputName; void AddUser() { _showUser.AddUser(new UserData() { Name = _inputName }); _inputName = &quot;&quot;; } void CallbackTestFunc() { _inputName = &quot;CallbackTest&quot;; // _inputName 변경 StateHasChanged(); // 수동 UI 갱신 }}여기서 중요한 점은 CallbackTestFunc()가 호출되어 _inputName이 변경되어도 UI가 자동으로 갱신이 안돼 수동으로 UI 갱신을 해주고 있다는 것이다.확인해보고 싶으면 StateHasChanged() 부분을 주석처리하고 실행해보자.이처럼 StateHasChanged()를 호출해 수동으로 UI를 갱신해주어도 되지만 다른 방법도 있다.ASP.NET Core에서 제공하는 EventCallback을 사용하는 것이다.EventCallback 사용법은 Action과 매우 비슷하지만 다른 점은 StateHasChanged()를 수동으로 호출할 필요가 없다.ShowUser.razor@using BlazorApp.Data;&amp;lt;p&amp;gt; Users: &amp;lt;b&amp;gt;@Users.Count()&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;br /&amp;gt;&amp;lt;ul class=&quot;list-group&quot;&amp;gt; @foreach (UserData user in Users) { &amp;lt;li @key=&quot;user&quot; class=&quot;list-group-item&quot;&amp;gt; &amp;lt;button type=&quot;button&quot; class=&quot;btn btn-link&quot; @onclick=&quot;(() =&amp;gt; KickUser(user))&quot;&amp;gt;[Kick]&amp;lt;/button&amp;gt; &amp;lt;label&amp;gt;@user.Name&amp;lt;/label&amp;gt; &amp;lt;/li&amp;gt; }&amp;lt;/ul&amp;gt;@code { [Parameter] public List&amp;lt;UserData&amp;gt; Users { get; set; } // Action 대신 EventCallback 사용 [Parameter] public EventCallback CallbackTest { get; set; } protected override void OnInitialized() { Users.Add(new UserData() { Name = &quot;define_chan&quot; }); Users.Add(new UserData() { Name = &quot;Rookiss&quot; }); Users.Add(new UserData() { Name = &quot;Dongglee&quot; }); } public void AddUser(UserData user) { Users.Add(user); } public void KickUser(UserData user) { Users.Remove(user); CallbackTest.InvokeAsync(null); // Parameter로 받은 함수 호출 }}User.razor@page &quot;/user&quot;@using BlazorApp.Data;&amp;lt;h3&amp;gt;Online Users&amp;lt;/h3&amp;gt;&amp;lt;!-- CallbackTestFunc도 Parameter로 전달 --&amp;gt;&amp;lt;ShowUser Users=&quot;_users&quot; CallbackTest=&quot;CallbackTestFunc&quot; @ref=&quot;_showUser&quot;&amp;gt;&amp;lt;/ShowUser&amp;gt;&amp;lt;br /&amp;gt;&amp;lt;div class=&quot;container&quot;&amp;gt; &amp;lt;div class=&quot;row&quot;&amp;gt; &amp;lt;div class=&quot;col&quot;&amp;gt; &amp;lt;input class=&quot;form-control&quot; placeholder=&quot;Add User&quot; @bind-value=&quot;_inputName&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;col&quot;&amp;gt; &amp;lt;button class=&quot;btn btn-primary&quot; type=&quot;button&quot; @onclick=&quot;AddUser&quot;&amp;gt;Add a User&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;@code { List&amp;lt;UserData&amp;gt; _users = new List&amp;lt;UserData&amp;gt;(); ShowUser _showUser; string _inputName; void AddUser() { _showUser.AddUser(new UserData() { Name = _inputName }); _inputName = &quot;&quot;; } void CallbackTestFunc() { _inputName = &quot;CallbackTest&quot;; // _inputName 변경 //StateHasChanged(); // EventCallback 사용시 호출 안해줘도 됨. }}실행시켜보면 StateHasChanged()를 호출하지 않았음에도 UI가 잘 갱신되는 것을 볼 수 있다." }, { "title": "[Blazor] Binding 보충", "url": "/posts/Binding%EB%B3%B4%EC%B6%A9/", "categories": "웹 서버, Blazor 입문", "tags": "Blazor, Binding", "date": "2022-03-14 11:43:00 +0900", "snippet": "속성(attribute)에도 binding할 수 있다HTML태그 속성(attribute)에도 binding을 할 수 있다.이전 포스트에서 만든 User 관리 페이지 코드를 가져와 테스트를 해보겠다. User 관리 페이지@page &quot;/user&quot;@using BlazorApp.Data;&amp;lt;h3&amp;gt;Online Users&amp;lt;/h3&amp;gt;&amp;lt;p&amp;gt; Users: &amp;lt;b&amp;gt;@_users.Count()&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;br /&amp;gt;&amp;lt;ul class=&quot;list-group&quot;&amp;gt; @foreach (UserData user in _users) { &amp;lt;li @key=&quot;user&quot; class=&quot;list-group-item&quot;&amp;gt; &amp;lt;button type=&quot;button&quot; class=&quot;btn btn-link&quot; @onclick=&quot;(() =&amp;gt; KickUser(user))&quot;&amp;gt;[Kick]&amp;lt;/button&amp;gt; &amp;lt;label&amp;gt;@user.Name&amp;lt;/label&amp;gt; &amp;lt;/li&amp;gt; }&amp;lt;/ul&amp;gt;&amp;lt;br /&amp;gt;&amp;lt;div class=&quot;container&quot;&amp;gt; &amp;lt;div class=&quot;row&quot;&amp;gt; &amp;lt;div class=&quot;col&quot;&amp;gt; &amp;lt;input class=&quot;form-control&quot; placeholder=&quot;Add User&quot; @bind-value=&quot;_inputName&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;col&quot;&amp;gt; &amp;lt;!-- 속성(attribute)에도 binding할 수 있다 --&amp;gt; &amp;lt;button class=&quot;@_btnClass&quot; type=&quot;button&quot; @onclick=&quot;AddUser&quot;&amp;gt;Add a User&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;@code { List&amp;lt;UserData&amp;gt; _users = new List&amp;lt;UserData&amp;gt;(); string _inputName; string _btnClass = &quot;btn btn-primary&quot;; // 버튼 class에 binding할 변수 protected override void OnInitialized() { _users.Add(new UserData() { Name = &quot;define_chan&quot; }); _users.Add(new UserData() { Name = &quot;Rookiss&quot; }); _users.Add(new UserData() { Name = &quot;Dongglee&quot; }); RefreshButton(); } void AddUser() { _users.Add(new UserData() { Name = _inputName }); _inputName = &quot;&quot;; RefreshButton(); } void KickUser(UserData user) { _users.Remove(user); RefreshButton(); } // 버튼 class 바꾸기 void RefreshButton() { if (_users.Count() % 2 == 0) _btnClass = &quot;btn btn-primary&quot;; else _btnClass = &quot;btn btn-secondary&quot;; }}주석으로 표시한 부분들을 유심히 보면 된다. @onclick과 같은 특수한 속성을 이용하지 않고 일반적인 속성에다 binding하여 지정해주고 있다. 이렇게 했을 경우 상황에 맞게 속성을 바꿔줄 수 있다.위 코드에서는 User 수에 따라 버튼 속성을 바꿔주고 있다.User 수에 따라 속성이 바뀌는 버튼속성(attribute)에 조건(conditional)을 붙일 수도 있다아깐 속성에 변수를 바로 binding하였지만 조건을 붙여 binding할 수도 있다.아까 코드에서 버튼에다 disabled 속성을 추가해 아래와 같이 넣어보자.&amp;lt;div class=&quot;container&quot;&amp;gt; &amp;lt;div class=&quot;row&quot;&amp;gt; &amp;lt;div class=&quot;col&quot;&amp;gt; &amp;lt;input class=&quot;form-control&quot; placeholder=&quot;Add User&quot; @bind-value=&quot;_inputName&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;col&quot;&amp;gt; &amp;lt;!-- 속성(attribute)자체에 조건(conditional)을 붙일 수도 있다 --&amp;gt; &amp;lt;button class=&quot;@_btnClass&quot; type=&quot;button&quot; @onclick=&quot;AddUser&quot; disabled=&quot;@(_users.Count()&amp;gt;=5)&quot;&amp;gt;Add a User&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;disabled 속성에 조건부 형식으로 넣고 있는 것을 볼 수 있다. User 수가 5를 넘으면 true가 돼 버튼이 비활성화가 될 것이고, User 수가 5 미만일 때는 false가 돼 버튼이 활성화가 될 것이다.User 수가 5를 넘어 비활성화가 된 버튼UI 수동 갱신지금까진 데이터가 바뀌거나 수정되면 UI가 바로 갱신되는 것을 보았지만 항상 갱신된다고 할 순 없다.간단하게 테스트를 해보자.프로젝트를 생성할 때 기본적으로 생성되는 Counter.razor 페이지를 수정하였다.@page &quot;/counter&quot;&amp;lt;!-- Timer를 쓰기 위해 --&amp;gt;@using System.Threading;&amp;lt;h1&amp;gt;Counter&amp;lt;/h1&amp;gt;&amp;lt;p&amp;gt;Current count: @currentCount&amp;lt;/p&amp;gt;&amp;lt;button class=&quot;btn btn-primary&quot; @onclick=&quot;IncrementCount&quot;&amp;gt;Click me&amp;lt;/button&amp;gt;&amp;lt;!-- Auto Increment 버튼 생성 --&amp;gt;&amp;lt;button class=&quot;btn btn-secondary&quot; @onclick=&quot;AutoIncrement&quot;&amp;gt;Auto Increment&amp;lt;/button&amp;gt;@code { private int currentCount = 0; private void IncrementCount() { currentCount++; } // 1초마다 IncrementCount()를 호출해 Count를 1씩 증가시켜준다. void AutoIncrement() { var timer = new Timer(x =&amp;gt; { InvokeAsync(() =&amp;gt; { IncrementCount(); }); }, null, 1000, 1000); }}Auto Increment 버튼을 누르면 Count가 1초마다 1씩 계속 증가하게 된다.그러나 실행시켜서 눌러보면 화면상에 Count는 그대로 인것을 볼 수 있다. Count가 제대로 증가하고 있는지 확인해보려면 원래 있던 Click me 버튼을 눌러보면 된다.Click me 버튼을 눌렀을 때는 UI가 자동적으로 갱신이 되었고, Auto Increment 버튼을 눌렀을 때는 UI가 자동적으로 갱신이 되지 않았다. 이유는 복잡하지만 일단 이 문제를 해결하는 방법은 수동으로 UI를 갱신시켜주면 된다.@code { private int currentCount = 0; private void IncrementCount() { currentCount++; } // 1초마다 IncrementCount()를 호출해 Count를 1씩 증가시켜준다. void AutoIncrement() { var timer = new Timer(x =&amp;gt; { InvokeAsync(() =&amp;gt; { IncrementCount(); StateHasChanged(); // 수동으로 UI 갱신 }); }, null, 1000, 1000); }}StateHasChanged()를 호출하면 component에 상태가 변경 되었음을 알리고, 그로 인해 component가 다시 렌더링된다. StateHasChanged()는 따로 구현해주어야 하는 것이 아니고 ASP.NET Core에서 제공되는 함수이다.StateHasChanged()를 추가하고 실행시켜보면 UI가 잘 갱신되는 것을 볼 수 있다." }, { "title": "[Blazor] Binding 실습", "url": "/posts/Binding%EC%8B%A4%EC%8A%B5/", "categories": "웹 서버, Blazor 입문", "tags": "Blazor, Binding", "date": "2022-03-10 16:21:00 +0900", "snippet": "Binding 실습 - 예제) User 관리 페이지Blazor에서 Binding 기능을 활용해보면서 User 현재 목록 출력 및 추가, 삭제가 가능한 User 관리 페이지를 만들어보자.User 관리 페이지 생성Pages 폴더에 ‘새 항목 추가 &amp;gt; Razor 구성 요소’를 선택해 User.razor를 생성한다.User 데이터 정의Data 폴더에 ‘새 항목 추가 &amp;gt; 클래스’를 선택해 UserData.cs를 생성하고 아래와 같이 정의한다.namespace BlazorApp.Data{ public class UserData { public string Name { get; set; } }}간단하게 User들을 구분해주기 위한 이름만 정의하였다.NavMenu.razor에 User 메뉴 추가Shared 폴더에 NavMenu.razor로 들어가 User 메뉴를 추가해둔다.&amp;lt;div class=&quot;@NavMenuCssClass&quot; @onclick=&quot;ToggleNavMenu&quot;&amp;gt; &amp;lt;ul class=&quot;nav flex-column&quot;&amp;gt; &amp;lt;li class=&quot;nav-item px-3&quot;&amp;gt; &amp;lt;NavLink class=&quot;nav-link&quot; href=&quot;&quot; Match=&quot;NavLinkMatch.All&quot;&amp;gt; &amp;lt;span class=&quot;oi oi-home&quot; aria-hidden=&quot;true&quot;&amp;gt;&amp;lt;/span&amp;gt; Home &amp;lt;/NavLink&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li class=&quot;nav-item px-3&quot;&amp;gt; &amp;lt;NavLink class=&quot;nav-link&quot; href=&quot;counter&quot;&amp;gt; &amp;lt;span class=&quot;oi oi-plus&quot; aria-hidden=&quot;true&quot;&amp;gt;&amp;lt;/span&amp;gt; Counter &amp;lt;/NavLink&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li class=&quot;nav-item px-3&quot;&amp;gt; &amp;lt;NavLink class=&quot;nav-link&quot; href=&quot;fetchdata&quot;&amp;gt; &amp;lt;span class=&quot;oi oi-list-rich&quot; aria-hidden=&quot;true&quot;&amp;gt;&amp;lt;/span&amp;gt; Fetch data &amp;lt;/NavLink&amp;gt; &amp;lt;/li&amp;gt; @* User 메뉴 추가 *@ &amp;lt;li class=&quot;nav-item px-3&quot;&amp;gt; &amp;lt;NavLink class=&quot;nav-link&quot; href=&quot;user&quot;&amp;gt; &amp;lt;span class=&quot;oi oi-list-rich&quot; aria-hidden=&quot;true&quot;&amp;gt;&amp;lt;/span&amp;gt; User &amp;lt;/NavLink&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt;&amp;lt;/div&amp;gt;여기까지 준비되었다면 User.razor로 돌아가 코드를 작성해본다.User 현재 목록 출력먼저 User들의 현재 목록을 출력해보자.User.razor@* 라우팅 경로 설정 *@@page &quot;/user&quot;@* BlazorApp.Data를 사용하겠다는 의미 *@@using BlazorApp.Data;&amp;lt;h3&amp;gt;Online Users&amp;lt;/h3&amp;gt;&amp;lt;p&amp;gt; Users: &amp;lt;b&amp;gt;@_users.Count()&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;br /&amp;gt;&amp;lt;ul class=&quot;list-group&quot;&amp;gt; @foreach (UserData user in _users) { &amp;lt;li @key=&quot;user&quot; class=&quot;list-group-item&quot;&amp;gt; &amp;lt;label&amp;gt;@user.Name&amp;lt;/label&amp;gt; &amp;lt;/li&amp;gt; }&amp;lt;/ul&amp;gt;@code { List&amp;lt;UserData&amp;gt; _users = new List&amp;lt;UserData&amp;gt;(); // 처음 페이지를 열때 호출된다. protected override void OnInitialized() { // 임시적으로 데이터 생성 _users.Add(new UserData() { Name = &quot;define_chan&quot; }); _users.Add(new UserData() { Name = &quot;Rookiss&quot; }); _users.Add(new UserData() { Name = &quot;Dongglee&quot; }); }}OnInitialized()에서 임시적으로 User 데이터를 생성해주고 있고, _users 리스트에 들어가 있는 데이터들을 foreach문으로 하나씩 꺼내 출력해주고 있다.실행시켜보면 그럴싸하게 표현되는 것을 볼 수 있다.User 목록 출력참고로 HTML 태그에 class=”” 속성 부분을 보면 Bootstrap에 미리 정의되어 있는 CSS를 적용시켜주고 있기 때문에 위와 같이 보이는 것이다.만약 Bootstrap 부분을 뺀다면 아래와 같은 모습일 것이다.&amp;lt;ul&amp;gt; @foreach (UserData user in _users) { &amp;lt;li @key=&quot;user&quot;&amp;gt; &amp;lt;label&amp;gt;@user.Name&amp;lt;/label&amp;gt; &amp;lt;/li&amp;gt; }&amp;lt;/ul&amp;gt;Bootstrap을 뺀 모습Bootstrap에 대해서도 공부해두면 좋지만 지금은 다 외워둘 필요는 없기 때문에 필요할때마다 검색해보는 것을 추천한다.User 추가 기능User를 추가하는 기능을 만들어보자.User.razor@page &quot;/user&quot;@using BlazorApp.Data;&amp;lt;h3&amp;gt;Online Users&amp;lt;/h3&amp;gt;&amp;lt;p&amp;gt; Users: &amp;lt;b&amp;gt;@_users.Count()&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;br /&amp;gt;&amp;lt;ul class=&quot;list-group&quot;&amp;gt; @foreach (UserData user in _users) { &amp;lt;li @key=&quot;user&quot; class=&quot;list-group-item&quot;&amp;gt; &amp;lt;label&amp;gt;@user.Name&amp;lt;/label&amp;gt; &amp;lt;/li&amp;gt; }&amp;lt;/ul&amp;gt;&amp;lt;br /&amp;gt;@* User 추가 기능 UI *@&amp;lt;div class=&quot;container&quot;&amp;gt; &amp;lt;div class=&quot;row&quot;&amp;gt; &amp;lt;div class=&quot;col&quot;&amp;gt; &amp;lt;input class=&quot;form-control&quot; placeholder=&quot;Add User&quot; @bind-value=&quot;_inputName&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;col&quot;&amp;gt; &amp;lt;button class=&quot;btn btn-primary&quot; type=&quot;button&quot; @onclick=&quot;AddUser&quot;&amp;gt;Add a User&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;@code { List&amp;lt;UserData&amp;gt; _users = new List&amp;lt;UserData&amp;gt;(); string _inputName; protected override void OnInitialized() { _users.Add(new UserData() { Name = &quot;define_chan&quot; }); _users.Add(new UserData() { Name = &quot;Rookiss&quot; }); _users.Add(new UserData() { Name = &quot;Dongglee&quot; }); } void AddUser() { _users.Add(new UserData() { Name = _inputName }); _inputName = &quot;&quot;; }}바인딩되는 부분과 함수가 연결되는 부분을 잘 살펴보자.실행시켜보면 잘 동작하는 것을 확인해 볼 수 있다.실행화면User를 추가한 모습또한 바인딩을 해놓은 상태에서 데이터를 추가하거나 수정하면 실시간으로 UI가 갱신되는 모습도 볼 수 있다.User 삭제 기능이어서 User를 삭제하는 기능도 만들어보자.@page &quot;/user&quot;@using BlazorApp.Data;&amp;lt;h3&amp;gt;Online Users&amp;lt;/h3&amp;gt;&amp;lt;p&amp;gt; Users: &amp;lt;b&amp;gt;@_users.Count()&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;br /&amp;gt;&amp;lt;ul class=&quot;list-group&quot;&amp;gt; @foreach (UserData user in _users) { &amp;lt;li @key=&quot;user&quot; class=&quot;list-group-item&quot;&amp;gt; @* 삭제 버튼 추가 *@ &amp;lt;button type=&quot;button&quot; class=&quot;btn btn-link&quot; @onclick=&quot;(() =&amp;gt; KickUser(user))&quot;&amp;gt;[Kick]&amp;lt;/button&amp;gt; &amp;lt;label&amp;gt;@user.Name&amp;lt;/label&amp;gt; &amp;lt;/li&amp;gt; }&amp;lt;/ul&amp;gt;&amp;lt;br /&amp;gt;@* User 추가 기능 UI *@&amp;lt;div class=&quot;container&quot;&amp;gt; &amp;lt;div class=&quot;row&quot;&amp;gt; &amp;lt;div class=&quot;col&quot;&amp;gt; &amp;lt;input class=&quot;form-control&quot; placeholder=&quot;Add User&quot; @bind-value=&quot;_inputName&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;col&quot;&amp;gt; &amp;lt;button class=&quot;btn btn-primary&quot; type=&quot;button&quot; @onclick=&quot;AddUser&quot;&amp;gt;Add a User&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;@code { List&amp;lt;UserData&amp;gt; _users = new List&amp;lt;UserData&amp;gt;(); string _inputName; protected override void OnInitialized() { _users.Add(new UserData() { Name = &quot;define_chan&quot; }); _users.Add(new UserData() { Name = &quot;Rookiss&quot; }); _users.Add(new UserData() { Name = &quot;Dongglee&quot; }); } void AddUser() { _users.Add(new UserData() { Name = _inputName }); _inputName = &quot;&quot;; } void KickUser(UserData user) { _users.Remove(user); }}여기서 유의깊게 볼 부분은 @onclick에서 KickUser() 함수와 연결한 부분이다.@* 삭제 버튼 추가 *@&amp;lt;button type=&quot;button&quot; class=&quot;btn btn-link&quot; @onclick=&quot;(() =&amp;gt; KickUser(user))&quot;&amp;gt;[Kick]&amp;lt;/button&amp;gt;User 데이터를 삭제하기 위해서는 인자를 받을 수 밖에 없는데 @onclick 속성은 인자가 없는 형태로만 받을 수 있다. 그렇다보니 람다를 이용해 인자가 없는 형태로 만들고 람다 캡처를 이용해 user라는 데이터를 넘겨주면서 간접적으로 호출해주고 있다.최종적으로 실행시켜보면서 기능들을 테스트해보자.실행화면User를 삭제한 모습" }, { "title": "[Blazor] Binding", "url": "/posts/Binding/", "categories": "웹 서버, Blazor 입문", "tags": "Blazor, Binding", "date": "2022-03-10 13:45:00 +0900", "snippet": "Blazer 프로젝트 생성Blazor Server 형식으로 만들경우 Visual Studio에서 ‘Blazor 앱 &amp;gt; Blazor 서버 앱’을 선택해 생성하면 된다.Razor Component(.razor)Blazor는 Razor Component들로 이루어져 있으며 생성방법은 ‘새 항목 추가 &amp;gt; Razor 구성 요소’를 선택해 생성하면 된다.Razor Component(.razor) 파일은 C#와 HTML 태그들을 사용해 구현된다.기본적으로 맨 위에는 필요한 선언문들이 들어가고, 중앙에는 C#과 혼합된 HTML 태그들이, 맨 아래 @code { } 부분은 전형적인 C#코드가 들어간다.ex) FetchData.razor@page &quot;/fetchdata&quot;@using BlazorApp.Data@inject WeatherForecastService ForecastService&amp;lt;h1&amp;gt;Weather forecast&amp;lt;/h1&amp;gt;&amp;lt;p&amp;gt;This component demonstrates fetching data from a service.&amp;lt;/p&amp;gt;@if (forecasts == null){ &amp;lt;p&amp;gt;&amp;lt;em&amp;gt;Loading...&amp;lt;/em&amp;gt;&amp;lt;/p&amp;gt;}else{ &amp;lt;table class=&quot;table&quot;&amp;gt; &amp;lt;thead&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;th&amp;gt;Date&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;Temp. (C)&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;Temp. (F)&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;Summary&amp;lt;/th&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/thead&amp;gt; &amp;lt;tbody&amp;gt; @foreach (var forecast in forecasts) { &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;@forecast.Date.ToShortDateString()&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;@forecast.TemperatureC&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;@forecast.TemperatureF&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;@forecast.Summary&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; } &amp;lt;/tbody&amp;gt; &amp;lt;/table&amp;gt;}@code { private WeatherForecast[] forecasts; protected override async Task OnInitializedAsync() { forecasts = await ForecastService.GetForecastAsync(DateTime.Now); }}Binding테스트를 위해 Pages 폴더에 Binding.razor라는 이름으로 Razor Component를 생성하고 아래와 같이 작성해본다.Binding.razor@page &quot;/binding&quot;&amp;lt;h3&amp;gt;Binding&amp;lt;/h3&amp;gt;&amp;lt;p&amp;gt;Value : @_value&amp;lt;/p&amp;gt;@code { int _value = 15;}Razor Component 파일에서는 ‘@page’를 사용해 라우팅 경로를 설정해줄 수 있다.‘@변수이름’ 형식으로 작성하면 실제 선언되어 있는 변수와 바인딩을 해주어 현재 변수에 저장되어 있는 값을 불러온다.필요한 변수와 함수는 아래 @code { }안에 C#으로 구현하면 된다.값이 잘 출력되는지 테스트해보기 위해 Shared 폴더에 NavMenu.razor 파일로 가 메뉴를 추가해본다.NavMenu.razor&amp;lt;div class=&quot;top-row pl-4 navbar navbar-dark&quot;&amp;gt; &amp;lt;a class=&quot;navbar-brand&quot; href=&quot;&quot;&amp;gt;BlazorApp&amp;lt;/a&amp;gt; &amp;lt;button class=&quot;navbar-toggler&quot; @onclick=&quot;ToggleNavMenu&quot;&amp;gt; &amp;lt;span class=&quot;navbar-toggler-icon&quot;&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/button&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div class=&quot;@NavMenuCssClass&quot; @onclick=&quot;ToggleNavMenu&quot;&amp;gt; &amp;lt;ul class=&quot;nav flex-column&quot;&amp;gt; &amp;lt;li class=&quot;nav-item px-3&quot;&amp;gt; &amp;lt;NavLink class=&quot;nav-link&quot; href=&quot;&quot; Match=&quot;NavLinkMatch.All&quot;&amp;gt; &amp;lt;span class=&quot;oi oi-home&quot; aria-hidden=&quot;true&quot;&amp;gt;&amp;lt;/span&amp;gt; Home &amp;lt;/NavLink&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li class=&quot;nav-item px-3&quot;&amp;gt; &amp;lt;NavLink class=&quot;nav-link&quot; href=&quot;counter&quot;&amp;gt; &amp;lt;span class=&quot;oi oi-plus&quot; aria-hidden=&quot;true&quot;&amp;gt;&amp;lt;/span&amp;gt; Counter &amp;lt;/NavLink&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li class=&quot;nav-item px-3&quot;&amp;gt; &amp;lt;NavLink class=&quot;nav-link&quot; href=&quot;fetchdata&quot;&amp;gt; &amp;lt;span class=&quot;oi oi-list-rich&quot; aria-hidden=&quot;true&quot;&amp;gt;&amp;lt;/span&amp;gt; Fetch data &amp;lt;/NavLink&amp;gt; &amp;lt;/li&amp;gt; @* 메뉴 추가 *@ &amp;lt;li class=&quot;nav-item px-3&quot;&amp;gt; &amp;lt;NavLink class=&quot;nav-link&quot; href=&quot;binding&quot;&amp;gt; &amp;lt;span class=&quot;oi oi-list-rich&quot; aria-hidden=&quot;true&quot;&amp;gt;&amp;lt;/span&amp;gt; Binding &amp;lt;/NavLink&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt;&amp;lt;/div&amp;gt;@code { private bool collapseNavMenu = true; private string NavMenuCssClass =&amp;gt; collapseNavMenu ? &quot;collapse&quot; : null; private void ToggleNavMenu() { collapseNavMenu = !collapseNavMenu; }}다른 메뉴 구문을 복사해 href 경로와 이름만 수정해주었다.실행시켜보면 좌측 사이드바에 Binding이라는 메뉴가 생겼고 눌러보면 _value 값이 잘 출력된 모습을 볼 수 있다.Binding방금은 값을 불러오는 쪽으로 바인딩을 하였지만 반대로도 가능하다.@page &quot;/binding&quot;&amp;lt;h3&amp;gt;Binding&amp;lt;/h3&amp;gt;&amp;lt;p&amp;gt;Value : @_value&amp;lt;/p&amp;gt;&amp;lt;input type=&quot;range&quot; step=&quot;1&quot; @bind-value=&quot;_value&quot; /&amp;gt;@code { int _value = 15;}&amp;lt;input&amp;gt; 태그에서 @bind-value 속성을 이용해 _value와 바인딩해주고 있다.실행시켜보면 range를 만질때마다 _value 값이 달라지는 것을 볼 수 있다.Binding참고로 지금은 마우스를 때야 값이 변하는데 이부분은 옵션을 추가해 설정해줄 수 있다.@page &quot;/binding&quot;&amp;lt;h3&amp;gt;Binding&amp;lt;/h3&amp;gt;&amp;lt;p&amp;gt;Value : @_value&amp;lt;/p&amp;gt;&amp;lt;input type=&quot;range&quot; step=&quot;1&quot; @bind-value=&quot;_value&quot; @bind-value:event=&quot;oninput&quot;/&amp;gt;@code { int _value = 15;}&amp;lt;input&amp;gt; 태그에 @bind-value:event 속성을 추가해 “oninput”이라고 설정해둔다. 그러면 마우스를 때지않아도 실시간으로 값이 변하는 모습을 볼 수 있다." }, { "title": "[ASP.NET Core] Hello Blazor Client + SPA", "url": "/posts/HelloBlazorClientSPA/", "categories": "웹 서버, ASP.NET Core 둘러보기", "tags": "Blazor, Blazor Client, SPA", "date": "2022-03-09 13:00:00 +0900", "snippet": "BlazorBlazor는 Microsoft에서 개발한 오픈소스 웹 개발 프레임워크이다. 가장 큰 특징으로는 .NET Core 기반의 C#으로 웹 앱을 개발할 수 있다.Blazor는 SPA(Single Page Application) 방식을 사용하고 서버측에서 동작하는 Blazor Server와 클라이언트측에서 동작하는 Blazor Client(WebAssembly) 형식이 있다.SPA(Single Page Application)SPA(Single Page Application)는 서버로부터 완전한 새로운 페이지를 불러오지 않고 현재의 페이지를 동적으로 다시 작성함으로써 사용자와 소통하는 웹 애플리케이션을 말한다.SPA이전의 전통적인 방식에서는 처음 웹홈페이지에 접속하면 서버에서는 그에 맞는 HTML 정보를 전달해준다. 그러고 다른 페이지에 들어간다거나 하면 서버에 요청해 또 그에 맞는 HTML 정보를 받는다. 그러다보니 매번 Page Reload가 발생하게 된다.예를 들어 네이버 웹툰에 들어가 아무 메뉴나 눌러보면 매번 페이지 자체가 Reload되는 것을 볼 수 있다. 네이버 웹툰 Page Reload그러나 SPA 방식에서는 처음 접속할때만 서버로부터 필요한 HTML 정보들을 받고 이후에는 AJAX를 통해 데이터만 요청하고 받아 클라이언트에서 렌더링하여 사용자에게 보여준다. AJAX(Asynchronous Javascript And XML) - Javascript 비동기 통신, XML 데이터를 주고 받는 기술Blazor Server 프로젝트를 생성해 실행시켜보면 차이를 볼 수 있다. Blazor Server 프로젝트 생성이런저런 메뉴들을 아무리 눌러봐도 Page Reload는 발생하지 않는다.Blazor Server(Server Side Blazor)Blazor Server는 ASP.NET Core 서버와 Razor 엔진을 이용한 에디션으로, 서버에서 대부분의 렌더링과 프로세싱이 이루어지는 것이 특징이다. 따라서 클라이언트의 부담이 적으며, 서버 쪽에서 이루어지는 업데이트들을 클라이언트 쪽에서 SignalR 기반의 웹소켓 방식으로 수신받는다.출처:Blazor Server DOM(Document Object Model) - 문서 객체 모델(HTML, XML 문서의 프로그래밍 interface), 우리가 작성한 HTML도 브라우저에 의해 파싱되어 DOM으로 변환된다.Blazor Client(Client side Blazor, WebAssembly)Blazor WebAssembly라고 불리기도 하는데, Blazor Server 에디션과 반대로 클라이언트에서 대부분의 렌더링이 이루어진다. 따라서 서버의 부담은 감소하지만 클라이언트의 부담이 높아지는 동시에 클라이언트가 처음 내려받는 파일의 용량도 증가한다. 하지만 서버를 거치지 않고 클라이언트에서 모든 로직이 실행되기 때문에 일반적인 윈도우 어플리케이션에 준하는 반응속도와 풍부한 사용자 경험을 제공할 수 있다는 장점이 있다.쉽게 말해 처음 접속할 때 필요한 모든 것들을 로드받고 이후에는 서버와 어떠한 통신도 하지 않으면서 알아서 혼자 잘 동작한다.출처:Blazor ClientBlazer Client 프로젝트 생성 및 실행Visual Studio에서 ‘Blazor 앱 &amp;gt; Blazor WebAssembly App’을 선택해 생성해 볼 수 있다.이대로 컴파일을 하여 실행시켜보면 아래와 같이 뜰 것이다.Blazor Client 실행 화면Blazor Server 프로젝트와 동일하게 뜨는 것을 볼 수 있으며 프로젝트 구조 또한 비슷한 형태를 띄고 있는 것을 볼 수 있다. 다만 Startup.cs파일이 없는 등 약간의 차이는 있다.Blazor Client는 위에서도 설명했듯이 처음 접속할 때말곤 서버와 통신하지 않고 클라이언트상에서만 동작하기 때문에 브라우저로 접속해 있는 상태에서 서버를 종료시켜도 잘 동작하는 것을 볼 수 있다.Blazor Server의 경우 중간에 서버를 종료시키면 브라우저상에서 바로 연결이 끊기는 현상을 관찰해볼 수 있다.Blazor Server 연결 끊김" }, { "title": "[ASP.NET Core] Hello Blazor Server", "url": "/posts/HelloBlazorServer/", "categories": "웹 서버, ASP.NET Core 둘러보기", "tags": "Blazor, Blazor Server, Razor Component, Bootstrap", "date": "2022-03-07 17:56:00 +0900", "snippet": "BlazorBlazor는 Microsoft에서 개발한 오픈소스 웹 개발 프레임워크이다. 가장 큰 특징으로는 .NET Core 기반의 C#으로 웹 앱을 개발할 수 있다.Blazor에서는 Blazor Server와 Blazor Client(WebAssembly) 형식이 있다.Blazor ServerBlazor Server는 ASP.NET Core 서버와 Razor 엔진을 이용한 에디션으로, 서버에서 대부분의 렌더링과 프로세싱이 이루어지는 것이 특징이다.Blazor Client(WebAssembly)Blazor WebAssembly라고 불리기도 하는데, Blazor Server 에디션과 반대로 클라이언트에서 대부분의 렌더링이 이루어진다.Blazor Server 프로젝트 생성Visual Studio에서 ‘Blazor 앱 &amp;gt; Blazor 서버 앱’을 선택해 Blazor Server 프로젝트를 생성해 볼 수 있다.이대로 컴파일을 하여 실행시켜보면 아래와 같이 뜰 것이다.Blazor Server 실행 화면Blazor Server 살펴보기위에서 생성한 Blazor Server 프로젝트의 코드를 살펴보면서 전체적인 동작 흐름을 알아보자.Program.cspublic class Program{ public static void Main(string[] args) { CreateHostBuilder(args).Build().Run(); } public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =&amp;gt; { webBuilder.UseStartup&amp;lt;Startup&amp;gt;(); });}먼저 Program.cs를 살펴보자면 Main()함수가 있는 것으로 보아 Blazor Server 또한 콘솔 프로그램인 것을 알 수 있고 Blazor Server를 실행시키면 Main()함수가 먼저 호출이 될 것이다.Main()함수가 호출되면 그 밑에 함수를 실행시키면서 Startup을 호출하는 것을 볼 수 있다.Startup.cspublic class Startup{ public Startup(IConfiguration configuration) { Configuration = configuration; } public IConfiguration Configuration { get; } // This method gets called by the runtime. Use this method to add services to the container. // For more information on how to configure your application, visit https://go.microsoft.com/fwlink/?LinkID=398940 public void ConfigureServices(IServiceCollection services) { services.AddRazorPages(); services.AddServerSideBlazor(); services.AddSingleton&amp;lt;WeatherForecastService&amp;gt;(); } // This method gets called by the runtime. Use this method to configure the HTTP request pipeline. public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } else { app.UseExceptionHandler(&quot;/Error&quot;); // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts. app.UseHsts(); } app.UseHttpsRedirection(); app.UseStaticFiles(); app.UseRouting(); app.UseEndpoints(endpoints =&amp;gt; { endpoints.MapBlazorHub(); endpoints.MapFallbackToPage(&quot;/_Host&quot;); }); }}Main함수에서 Startup을 호출하면 ConfigureServices와 Configure이 실행되게 되는데 서비스들을 연결하고 라우팅 설정 등을 하게된다.public void ConfigureServices(IServiceCollection services){ services.AddRazorPages(); services.AddServerSideBlazor(); services.AddSingleton&amp;lt;WeatherForecastService&amp;gt;();}ConfigureServices에서는 어떠한 서비스들을 사용할 것인지를 추가해주는 역할을 한다. Blazor Server 프로젝트에서는 기본적으로 AddRazorPages(), AddServerSideBlazor()를 추가해주고 있는 것을 알 수 있다. 그 밑에 AddSingleton&amp;lt;WeatherForecastService&amp;gt;()의 경우 현재 자동으로 생성된 예제에서 추가한 서비스이다. 이름이 WeatherForecastService인 것으로 보아 날씨 관련된 서비스인 것으로 보인다.public void Configure(IApplicationBuilder app, IWebHostEnvironment env){ ... app.UseEndpoints(endpoints =&amp;gt; { endpoints.MapBlazorHub(); endpoints.MapFallbackToPage(&quot;/_Host&quot;); });}Configure에서는 라우팅 설정 및 여러 설정들을 해주는데 여기서 가장 중요한 부분은 Endpoints 부분이다. Endpoints는 쉽게 말해 어떤 주소를 입력하였을 때 어떤 애로 연동시켜줄 것인지 매핑해주는 부분이라고 생각하면 된다.코드를 대략적으로 봐보면 endpoints를 BlazorHub와 매핑시켜주고 있고, FallbackToPage라고 _Host 페이지와 연결시켜주고 있는 것으로 보아 현재 웹 서버 주소로 접속하면 _Host 페이지와 연결시켜준다라는 것을 알 수 있다.그러면 _Host 페이지가 실제로 우리에게 보여지는 페이지라는 의미인데 _Host 페이지 파일은 Pages 폴더 안에 _Host.cshtml 이름으로 찾아볼 수 있다._Host.cshtml&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;utf-8&quot; /&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&amp;gt; &amp;lt;title&amp;gt;HelloBlazorServer&amp;lt;/title&amp;gt; &amp;lt;base href=&quot;~/&quot; /&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap/bootstrap.min.css&quot; /&amp;gt; &amp;lt;link href=&quot;css/site.css&quot; rel=&quot;stylesheet&quot; /&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;app&amp;gt; &amp;lt;component type=&quot;typeof(App)&quot; render-mode=&quot;ServerPrerendered&quot; /&amp;gt; &amp;lt;/app&amp;gt; &amp;lt;div id=&quot;blazor-error-ui&quot;&amp;gt; &amp;lt;environment include=&quot;Staging,Production&quot;&amp;gt; An error has occurred. This application may no longer respond until reloaded. &amp;lt;/environment&amp;gt; &amp;lt;environment include=&quot;Development&quot;&amp;gt; An unhandled exception has occurred. See browser dev tools for details. &amp;lt;/environment&amp;gt; &amp;lt;a href=&quot;&quot; class=&quot;reload&quot;&amp;gt;Reload&amp;lt;/a&amp;gt; &amp;lt;a class=&quot;dismiss&quot;&amp;gt;🗙&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script src=&quot;_framework/blazor.server.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;_Host.cshtml를 확인해보면 html 태그들로 구성되어 있는 것을 볼 수 있으며, 본문 내용을 담고 있는 &amp;lt;body&amp;gt;태그 안을 살펴보면 &amp;lt;app&amp;gt;태그 안에 &amp;lt;component&amp;gt;태그로 “typeof(App)”을 불러오고 있는 것을 볼 수 있다.App은 Pages 폴더 바깥쪽에 App.razor 이름으로 찾아볼 수 있다.App.razor&amp;lt;Router AppAssembly=&quot;@typeof(Program).Assembly&quot;&amp;gt; &amp;lt;Found Context=&quot;routeData&quot;&amp;gt; &amp;lt;RouteView RouteData=&quot;@routeData&quot; DefaultLayout=&quot;@typeof(MainLayout)&quot; /&amp;gt; &amp;lt;/Found&amp;gt; &amp;lt;NotFound&amp;gt; &amp;lt;LayoutView Layout=&quot;@typeof(MainLayout)&quot;&amp;gt; &amp;lt;p&amp;gt;Sorry, there&#39;s nothing at this address.&amp;lt;/p&amp;gt; &amp;lt;/LayoutView&amp;gt; &amp;lt;/NotFound&amp;gt;&amp;lt;/Router&amp;gt;App.razor에서는 Found, NotFound로 나눠져있는 것을 볼 수 있으며, Found일 때를 보면 “@typeof(MainLayout)”을 불러오고 있는 것을 알 수 있다.MainLayout은 Shared 폴더안에 MainLayout.razor 이름으로 찾아볼 수 있다.Blazor는 이런식으로 Component 단위로 관리하고 있는 것을 볼 수 있고 Component 파일 확장자를 보면 .razor인 것을 알 수 있다. .razor 파일은 Razor Component라고 하기도 하며 ‘새 항목 추가 &amp;gt; Razor 구성 요소’를 선택해 생성할 수 있다. Razor Component 파일은 Blazor에서 사용하는 파일 형식이다.MainLayout.razor&amp;lt;div class=&quot;sidebar&quot;&amp;gt; &amp;lt;NavMenu /&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div class=&quot;main&quot;&amp;gt; &amp;lt;div class=&quot;top-row px-4&quot;&amp;gt; &amp;lt;a href=&quot;https://docs.microsoft.com/aspnet/&quot; target=&quot;_blank&quot;&amp;gt;About&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;content px-4&quot;&amp;gt; @Body &amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;MainLayout.razor를 보면 sidebar와 main으로 구역이 나눠져 있다. 이름만 보고 예측해보자면 사용자에게 보여지는 화면에서 좌측 부분이 sidebar, 나머지 부분이 main 구역으로 예측해볼 수 있다. (실제로 그러함)sidebar 구역 main 구역자세히 확인해보고 싶으면 또 들어가보면 된다. sidebar 부분을 보면 &amp;lt;NavMenu /&amp;gt;라고 되어 있다. NavMenu부분은 Shared 폴더안에 NavMenu.razor 이름으로 있다.NavMenu.razor&amp;lt;div class=&quot;top-row pl-4 navbar navbar-dark&quot;&amp;gt; &amp;lt;a class=&quot;navbar-brand&quot; href=&quot;&quot;&amp;gt;HelloBlazorServer&amp;lt;/a&amp;gt; &amp;lt;button class=&quot;navbar-toggler&quot; @onclick=&quot;ToggleNavMenu&quot;&amp;gt; &amp;lt;span class=&quot;navbar-toggler-icon&quot;&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/button&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div class=&quot;@NavMenuCssClass&quot; @onclick=&quot;ToggleNavMenu&quot;&amp;gt; &amp;lt;ul class=&quot;nav flex-column&quot;&amp;gt; &amp;lt;li class=&quot;nav-item px-3&quot;&amp;gt; &amp;lt;NavLink class=&quot;nav-link&quot; href=&quot;&quot; Match=&quot;NavLinkMatch.All&quot;&amp;gt; &amp;lt;span class=&quot;oi oi-home&quot; aria-hidden=&quot;true&quot;&amp;gt;&amp;lt;/span&amp;gt; Home &amp;lt;/NavLink&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li class=&quot;nav-item px-3&quot;&amp;gt; &amp;lt;NavLink class=&quot;nav-link&quot; href=&quot;counter&quot;&amp;gt; &amp;lt;span class=&quot;oi oi-plus&quot; aria-hidden=&quot;true&quot;&amp;gt;&amp;lt;/span&amp;gt; Counter &amp;lt;/NavLink&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li class=&quot;nav-item px-3&quot;&amp;gt; &amp;lt;NavLink class=&quot;nav-link&quot; href=&quot;fetchdata&quot;&amp;gt; &amp;lt;span class=&quot;oi oi-list-rich&quot; aria-hidden=&quot;true&quot;&amp;gt;&amp;lt;/span&amp;gt; Fetch data &amp;lt;/NavLink&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt;&amp;lt;/div&amp;gt;@code { private bool collapseNavMenu = true; private string NavMenuCssClass =&amp;gt; collapseNavMenu ? &quot;collapse&quot; : null; private void ToggleNavMenu() { collapseNavMenu = !collapseNavMenu; }}여기에서도 &amp;lt;div&amp;gt;로 구역이 나누어져 있는 것을 볼 수 있는데 첫 번째 구역은 HelloBlazorServer라는 문구가 나오는 걸로 보아 sidebar에서 위쪽 구역을 나타내는 것으로 볼 수 있고, 그 다음 구역은 Home, Counter, Fetch data라는 문구가 등장하는 것으로 보아 바로 그 밑 메뉴들을 나타내는 것을 알 수 있다.메뉴들도 관찰해보면 link가 걸려 있는데 href 속성으로 연결되어있는 것을 볼 수 있다. 각 Counter, Fetch data 문구는 “counter”, “fetchdata” 페이지와 연결되어 있고 각 “counter”, “fetchdata” 페이지는 Pages 폴더에 Counter.razor, FetchData.razor 이름으로 있다.Counter.razor@page &quot;/counter&quot;&amp;lt;h1&amp;gt;Counter&amp;lt;/h1&amp;gt;&amp;lt;p&amp;gt;Current count: @currentCount&amp;lt;/p&amp;gt;&amp;lt;button class=&quot;btn btn-primary&quot; @onclick=&quot;IncrementCount&quot;&amp;gt;Click me&amp;lt;/button&amp;gt;@code { private int currentCount = 0; private void IncrementCount() { currentCount++; }}여기서 중요하게 볼만한 부분은 첫 줄에 @page “/counter” 부분이다. Blazor에서는 이런식으로 페이지 경로를 정의해주고 있다. 아까 NavMenu.razor에서 href=”counter” 라고 설정해 놓았는데 이 부분과 위에 @page “/counter” 부분과 맞아야 연결이 된다.또한 Blazor의 특징으로 MVC 모델에서는 View와 Controller를 아에 따로 관리를 하였고, Razor Pages에서는 View와 Controller를 상하위 파일로 묶어 관리하였는데 Blazor에서는 .razor 파일 안에 @code 를 넣어 View와 Controller를 한 파일로 관리하고 있다.Counter 페이지FetchData.razor@page &quot;/fetchdata&quot;@using HelloBlazorServer.Data@inject WeatherForecastService ForecastService&amp;lt;h1&amp;gt;Weather forecast&amp;lt;/h1&amp;gt;&amp;lt;p&amp;gt;This component demonstrates fetching data from a service.&amp;lt;/p&amp;gt;@if (forecasts == null){ &amp;lt;p&amp;gt;&amp;lt;em&amp;gt;Loading...&amp;lt;/em&amp;gt;&amp;lt;/p&amp;gt;}else{ &amp;lt;table class=&quot;table&quot;&amp;gt; &amp;lt;thead&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;th&amp;gt;Date&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;Temp. (C)&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;Temp. (F)&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;Summary&amp;lt;/th&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/thead&amp;gt; &amp;lt;tbody&amp;gt; @foreach (var forecast in forecasts) { &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;@forecast.Date.ToShortDateString()&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;@forecast.TemperatureC&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;@forecast.TemperatureF&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;@forecast.Summary&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; } &amp;lt;/tbody&amp;gt; &amp;lt;/table&amp;gt;}@code { private WeatherForecast[] forecasts; protected override async Task OnInitializedAsync() { forecasts = await ForecastService.GetForecastAsync(DateTime.Now); }}FetchData.razor 또한 Counter.razor와 비슷하며, 여기서 볼만한 부분은 if else문과 foreach문을 html 태그들과 섞어서 사용할 수도 있다는 부분이다.Counter 페이지여기까지 코드들을 무작정 따라가보면서 대략적이라도 Blazor Server 동작과정과 구조를 살펴보았는데 웹 서버는 이처럼 구조가 복잡한 면을 가지고 있다보니 이렇게 무작정 코드들을 따라가보는 것도 중요하다.bootstrap추가적으로 하나 더 언급하자면 웹페이지를 만들 때 전문적으로 꾸밀 것이 아니라면 일일이 CSS코드를 짜는 것이 번거로울 것이다. 그렇기에 라이브러리를 활용하여 CSS를 적용해볼 수 있다.방금 만들어본 Blazor Server 프로젝트 또한 살펴보면 bootstrap이라는 라이브러리를 사용하고 있는 것을 확인해 볼 수 있다.Blazor Server 프로젝트안 bootstrap 파일Bootstrap은 각종 레이아웃, 버튼, 입력창 등의 디자인과 기능을 CSS와 JavaScript로 만들어 놓은 프레임워크이다.Bootstrap또한 공부해 놓으면 좋다." }, { "title": "[ASP.NET Core] Hello WebAPI", "url": "/posts/HelloWebAPI/", "categories": "웹 서버, ASP.NET Core 둘러보기", "tags": "WebAPI", "date": "2022-03-07 14:33:00 +0900", "snippet": "WebAPIWebAPI는 웹 서버 또는 웹 브라우를 위한 인터페이스를 말한다.WebAPI 프로젝트를 MVC 구조와 비교하자면 Model-View-Controller에서 View가 빠진 느낌이라고 생각하면 이해하기 편하다.WebAPI 프로젝트 생성Visual Studio에서 ‘ASP.NET Core 웹 애플리케이션 &amp;gt; API’를 선택해 WebAPI 프로젝트를 생성해 볼 수 있다.이대로 컴파일하여 실행시켜보면 아래와 같이 뜰 것이다.ASP.NET Core WebAPI 실행 화면웹페이지 화면이라기엔 이상하게 보일 수 있는데 정상적으로 실행된 화면이다.이것이 MVC, Razor Pages와 webAPI의 차이점으로 View가 따로 없다는 것을 알 수 있다.빈 프로젝트에서 시작WebAPI 템플릿을 이용하여 프로젝트를 만들어도 되지만 WebAPI 프로젝트 구조 및 동작원리를 이해하기 위해 빈 프로젝트에서부터 만들어보겠다.빈 프로젝트 생성‘새 프로젝트 생성 &amp;gt; ASP.NET Core 웹 애플리케이션 &amp;gt; 비어 있음’을 선택해 빈 프로젝트를 생성한다.빈 프로젝트가 생성 되었다면 Models와 Controllers 폴더를 생성한다. Models에서는 데이터들을 정의 및 관리하고 Controllers에서는 데이터 요청 및 응답에 대한 처리를 할 것이다. Models Controllers Program.cs Startup.csModels먼저 간단한 메세지를 표현할 데이터를 정의해주자. Models 폴더에서 ‘새 항목 추가 &amp;gt; 클래스 &amp;gt; 파일이름 HelloMessage.cs’를 생성하고 아래와 같이 정의한다.public class HelloMessage{ public string Message { get; set; }}Controllers그 다음 간단한 메세지를 전달할 Controller를 생성해보자.Controllers 폴더에 ‘새 항목 추가 &amp;gt; API 컨트롤러 클래스 - 비어있 &amp;gt; 파일이를 ValuesController.cs’를 생성해준다.ValuesController.cs[Route(&quot;api/[controller]&quot;)][ApiController]public class ValuesController : ControllerBase{}코드를 작성하기전 먼저 첫 번째 줄을 살펴보면 라우팅 설정을 해주고 있는 것을 볼 수 있다.WebAPI 프로젝트에서는 이렇게 각 Controller에서 라우팅 설정을 해주고 있다.MVC, Razor Pages 프로젝트와 비교해보자면 MVC 프로젝트에서는 Startup.cs에서 pattern을 설정해 매핑시켜주고 있었고, Razor Pages 프로젝트에서는 pattern을 따로 설정해주진 않았지만 알아서 Pages 폴더 안에 있는 페이지와 매핑시켜주었다.마저 ValuesController.cs를 작성해보자.[Route(&quot;api/[controller]&quot;)][ApiController]public class ValuesController : ControllerBase{ [HttpGet] public List&amp;lt;HelloMessage&amp;gt; Get() { List&amp;lt;HelloMessage&amp;gt; messages = new List&amp;lt;HelloMessage&amp;gt;(); messages.Add(new HelloMessage() { Message = &quot;Hello Web API 1 ! &quot; }); messages.Add(new HelloMessage() { Message = &quot;Hello Web API 2 ! &quot; }); messages.Add(new HelloMessage() { Message = &quot;Hello Web API 3 ! &quot; }); return messages; }}HttpGet 방식으로 요청이 들어올 경우 Get()이 호출돼 메세지들을 반환해주게 된다.Startup마지막으로 Startup.cs에서 Controllers들을 연결시켜주고 실행시켜보자.public class Startup{ // This method gets called by the runtime. Use this method to add services to the container. // For more information on how to configure your application, visit https://go.microsoft.com/fwlink/?LinkID=398940 public void ConfigureServices(IServiceCollection services) { services.AddControllers(); // Controllers들을 사용하겠다는 의미 } // This method gets called by the runtime. Use this method to configure the HTTP request pipeline. public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } app.UseRouting(); app.UseEndpoints(endpoints =&amp;gt; { endpoints.MapControllers(); // Controllers들을 연결시켜주겠다는 의미 }); }}실행시켜보면 아래와 같이 뜰 것이다.첫 실행 화면잘못된것이 아니고 WebAPI에서는 기본적인 Index라는 View가 없기 때문이다.아까 작성한 Controller가 잘 동작하는지 확인해보기 위해서는 Controller에서 라우팅 설정을 했던 부분을 생각해보면 된다.ValuesController.cs[Route(&quot;api/[controller]&quot;)]“api/[controller]” 라고 설정되어 있으니 다시 웹페이지화면에서 주소 옆에 ‘api/values’라고 입력해보자.api/values 화면일단 아까 작성한 메세지로 보이는 데이터가 뜰 것이다.좀 더 정확하게 확인해보려면 F12를 눌러 네트워크에 들어가 방금 페이지를 새로고침해보면 어떠한 데이터들이 오고 있는지 확인해볼 수 있다. 또한 지금은 데이터들이 json 형식으로 오고 있다는 것을 알 수 있다.F12로 데이터 전송 확인WebAPI는 이런식으로 데이터만 전송해주는 역할을 하기 때문에 따로 View가 필요없고 클라이언트에서는 이러한 데이터를 받아 UI와 연동해 표현해주면 된다.웹서버에서 View 정보까지 왜 굳이 전송할 필요가 없는지에 대해서는 예를 들어 유니티와 연동한다고 하였을 때 유니티에서는 어짜피 프리팹화 되어 있는 UI들로 표현해야하기 때문에 html 태그로 이루어진 정보가 필요 없고, 웹 서비스를 개발한다 해도 어떻게 표현해야한다는 강압적인 규칙이 따로 없다보니 클라이언트에서는 데이터들만 받아 자유롭게 표현할 수 있게 된다. 그렇기에 WebAPI는 좀 더 범용적으로 데이터들을 활용할 수 있다는 장점이 있다." }, { "title": "[ASP.NET Core] Hello Razor Pages", "url": "/posts/HelloRazorPages/", "categories": "웹 서버, ASP.NET Core 둘러보기", "tags": "Razor Pages", "date": "2022-03-03 15:18:00 +0900", "snippet": "Razor PagesASP.NET Core의 Razor Pages는 이전 MVC(Model-View-Controller) 방식을 사용하는 것보다 좀 더 쉽고 생산적으로 개발할 수 있도록 나온 방식이다. ASP.NET Core Razor Pages 가 뭘까?MVC와 유사한 면도 있지만 Razor Pages는 Model-View-Controller에서 View와 Controller가 합쳐진 느낌이라고 생각하면 이해하기 편할 것 같다.Razor Pages 프로젝트 생성Visual Studio에서 ‘ASP.NET Core 웹 애플리케이션 &amp;gt; 웹 응용 프로그램’을 선택해 Razor Pages 프로젝트를 생성해 볼 수 있다.이대로 컴파일을 하여 실행시켜보면 아래와 같이 뜰 것이다.ASP.NET Core Razor Pages 실행 화면빈 프로젝트에서 시작Razor Pages 템플릿을 이용하여 프로젝트를 만들어도 되지만 Razor Pages 프로젝트 구조 및 동작원리를 이해하기 위해 빈 프로젝트에서부터 만들어보겠다.빈 프로젝트 생성‘새 프로젝트 생성 &amp;gt; ASP.NET Core 웹 애플리케이션 &amp;gt; 비어 있음’을 선택해 빈 프로젝트를 생성한다.빈 프로젝트가 생성 되었다면 Models와 Pages 폴더를 생성한다. Models에서는 데이터들을 정의 및 관리하고 Pages에서는 페이지들을 관리할 것이다. Models Pages Program.cs Startup.csModels먼저 간단한 메세지를 표현할 데이터를 정의해주자. Models 폴더에서 ‘새 항목 추가 &amp;gt; 클래스 &amp;gt; 파일이름 HelloMessage.cs’를 생성하고 아래와 같이 정의한다.public class HelloMessage{ public string Message { get; set; }}Pages그 다음 페이지를 하나 생성해보자. Pages 폴더에서 ‘새 항목 추가 &amp;gt; Razor 페이지 &amp;gt; 파일이름 Index.cshtml’를 생성하고, import를 해주어야 하는 것이 있어 ‘새 항목 추가 &amp;gt; Razor 뷰 가져오기’를 통해 _ViewImports.cshtml 파일도 생성하자. _ViewImports.cshtml에 관한 설명_ViewImports.cshtml는 아래와 같이 작성해놓으면 된다.@using HelloEmpty@using HelloEmpty.Models@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers페이지를 생성하고 보면 특이한 점을 볼 수 있다. Index.cshtml파일을 생성함과 동시에 아래에 Index.cshtml.cs파일도 생성된 것을 볼 수 있다.Index.cshtml과 Index.cshtml.cs이것이 Razor Pages의 방식이라고 볼 수 있고 Index.cshtml이 MVC에서의 View, Index.cshtml.cs가 MVC에서의 Controller라고 생각하면 된다.Razor Pages에서는 이런 식으로 View와 Controller를 묶어서 관리한다.그럼 Index.cshtml과 Index.cshtml.cs도 작성해보자.// Index.cshtml.cspublic class IndexModel : PageModel{ // 모델 바인딩 참가 암시 [BindProperty] public HelloMessage HelloMsg { get; set; } public string Noti { get; set; } public void OnGet() { this.HelloMsg = new HelloMessage() { Message = &quot;Hello Razor Pages&quot; }; } public void OnPost() { this.Noti = &quot;Message Changed&quot;; }}@page@model HelloEmpty.Pages.IndexModel&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Hello Razor Pages !&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;@Model.HelloMsg.Message&amp;lt;/h1&amp;gt; &amp;lt;hr /&amp;gt; &amp;lt;h2&amp;gt;@Model.Noti&amp;lt;/h2&amp;gt; &amp;lt;form method=&quot;post&quot;&amp;gt; &amp;lt;label asp-for=&quot;HelloMsg.Message&quot;&amp;gt;Enter Message&amp;lt;/label&amp;gt; &amp;lt;br /&amp;gt; &amp;lt;input type=&quot;text&quot; asp-for=&quot;HelloMsg.Message&quot; /&amp;gt; &amp;lt;br /&amp;gt; &amp;lt;button type=&quot;submit&quot;&amp;gt;Submit&amp;lt;/button&amp;gt; &amp;lt;/form&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;Index 페이지를 호출한다면 먼저 Index.cshtml.cs 안의 OnGet()이 호출되고 Index.cshtml를 읽어 사용자에게 보여주게 된다. 또한 사용자에게 출력된 페이지에서 submit 버튼을 누르게 되면 post방식으로 호출하게되어 OnPost() 함수가 호출된다.Startup마지막으로 내가 만든 페이지를 Startup.cs에서 연결시켜주어야 한다.public class Startup{ // This method gets called by the runtime. Use this method to add services to the container. // For more information on how to configure your application, visit https://go.microsoft.com/fwlink/?LinkID=398940 public void ConfigureServices(IServiceCollection services) { services.AddRazorPages(); } // This method gets called by the runtime. Use this method to configure the HTTP request pipeline. public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } app.UseRouting(); app.UseEndpoints(endpoints =&amp;gt; { endpoints.MapRazorPages(); }); }}Startup.cs에서 수정한 부분만 살펴보자면public void ConfigureServices(IServiceCollection services){ services.AddRazorPages();}services.AddRazorPages();는 Razor Pages를 사용하겠다는 의미이다.app.UseEndpoints(endpoints =&amp;gt;{ endpoints.MapRazorPages();});endpoints.MapRazorPages();는 endpoints를 내 Razor Pages와 연동시키겠다는 의미이다.이대로 실행시켜보면 아래와 같은 페이지의 모습이 뜰 것이다. 또한 중앙에 아무 문자열을 입력하고 submit을 눌려보면 페이지속 Message가 바뀌는 것을 볼 수 있다.첫 실행화면Test!라고 입력한 후 submit을 누른 화면MVC와 Razor Pages 비교MVC 방식으로도 코드를 작성해보고 Razor Pages 방식으로도 코드를 작성해보았다면 전체적으로 비교적 Razor Pages 방식이 단순하다라는 것을 느낄 수 있을 것이다.MVC의 경우 Model-View_Controller가 완전 분리되어 있다보니 View에서 해당 Controller를 연동시켜줄 때 코드 상에서 지정해주어야하고 Controller와 View가 1대 다로 연결될 수도 있기에 코드가 길어지거나 관리하기가 복잡해 질 수 있다. 그러나 Razor Pages의 경우 각 View마다 해당 Controller가 1대 1로 매핑이 되어 있기 때문에 이 부분에 대해선 실수를 줄일 수 있고 관리하기가 편할 수 있다.추가적으로 MVC에선 Startup.cs에서 endpoints를 설정해줄 때 pattern을 이용해 매핑을 해주었는데 Razor Pages에선 따로 pattern을 이용해 설정해주지 않은 것을 볼 수 있다. Razor Pages의 경우 ‘{웹서버주소}/Index’라고 입력하면 알아서 Pages 폴더 안에 있는 Index 페이지와 매핑해준다. 또한 실행시켜보면 주소란에 따로 /Index가 표시되어 있지 않은데 기본값이 /Index라는 것을 알 수 있다." }, { "title": "[ASP.NET Core] Hello MVC #2", "url": "/posts/HelloMVC-2/", "categories": "웹 서버, ASP.NET Core 둘러보기", "tags": "MVC", "date": "2022-03-03 14:18:00 +0900", "snippet": "빈 프로젝트에서 시작앞에서는 MVC 템플릿을 이용하여 프로젝트를 생성해보고 바로 실행해보았지만 이번에는 MVC 동작원리 등을 알아보기 위해 빈 프로젝트에서 하나하나씩 부품 맞추기 형식으로 MVC구조를 살펴보겠다.빈 프로젝트 생성‘새 프로젝트 생성 &amp;gt; ASP.NET Core 웹 애플리케이션 &amp;gt; 비어 있음’을 선택해 빈 프로젝트를 생성한다.빈 프로젝트를 생성하였다면 먼저 Models, Views, Controllers 폴더를 생성하고 Views 폴더안에는 Home이라는 폴더를 생성해놓자. Controllers Models Views Home Program.cs Startup.csModels다음 Models 폴더 안에 ‘새 항목 추가 &amp;gt; 클래스 &amp;gt; 파일이름 HelloMessage.cs’를 생성하여 간단한 메세지를 표현할 데이터를 정의해보자.public class HelloMessage{ public string Message { get; set; }}Controllers다음 Controllers 폴더로 가서는 ‘새 항목 추가 &amp;gt; 컨트롤러 클래스 - 비어 있 &amp;gt; 파일이름 HomeController.cs’를 생성하여 Home에 있는 Index 페이지를 열었을 때 어떤 데이터를 표현해주면 되는지 전달해보자.public class HomeController : Controller{ public IActionResult Index() { HelloMessage msg = new HelloMessage() { Message = &quot;Welcome to Asp.Net MVC !&quot; }; ViewBag.Noti = &quot;Input message and click submit&quot;; // ViewBag을 이용하여 View에 데이터를 넘겨줄 수 있음. return View(msg); // 어떤 UI를 표시해주면 되는지 반환 }}주의할 점은 Controller 이름과 함수 이름을 작성할때 View에 있는 페이지 이름과 맞게 작성해야한다. (예: Home안에 Index 페이지 -&amp;gt; HomeController 클래스 안에 Index() 함수)Views다음으로는 Views 폴더로 가서 방금 작성한 Controller와 연동 될 View를 생성한다. ‘새 항목 추가 &amp;gt; Razor 뷰 - 비어 있음 &amp;gt; 파일이름 Index.cshtml’.cshtml 파일은 C#과 HTML이 섞여있는 파일로 ASP.NET Core에서 자체적으로 활용하고 있는 파일형식이다.Index.cshtml 파일을 생성하였다면 아래와 같이 작성해보자.@model HelloEmpty.Models.HelloMessage&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Hello MVC !&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;@Model.Message&amp;lt;/h1&amp;gt; &amp;lt;hr /&amp;gt; &amp;lt;h2&amp;gt;@ViewBag.Noti&amp;lt;/h2&amp;gt; &amp;lt;form asp-controller=&quot;Home&quot; asp-action=&quot;Index&quot; method=&quot;post&quot;&amp;gt; &amp;lt;label asp-for=&quot;Message&quot;&amp;gt;Enter Message&amp;lt;/label&amp;gt; &amp;lt;br /&amp;gt; &amp;lt;input type=&quot;text&quot; asp-for=&quot;Message&quot; /&amp;gt; &amp;lt;br /&amp;gt; &amp;lt;button type=&quot;submit&quot;&amp;gt;Submit&amp;lt;/button&amp;gt; &amp;lt;/form&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;코드를 보면 HTML 태그를 사용하고 있는 것을 볼 수 있지만 기존 HTML과 다르게 @가 많이 보이는 것을 알 수 있다. @부분은 C#코드를 의미한다고 생각하면 된다.코드를 하나하나 살펴보자면@model HelloEmpty.Models.HelloMessage첫 줄에 나오는 부분은 HelloEmpty.Models.HelloMessage를 사용하겠다는 의미이다.&amp;lt;h1&amp;gt;@Model.Message&amp;lt;/h1&amp;gt;&amp;lt;hr /&amp;gt;&amp;lt;h2&amp;gt;@ViewBag.Noti&amp;lt;/h2&amp;gt;@없이 그냥 Model.Message라고 입력하면 그냥 문자열로 인식하지만 @를 붙이면 C#코드처럼 Model.Message에 접근하여 데이터를 불러오게 된다.&amp;lt;form asp-controller=&quot;Home&quot; asp-action=&quot;Index&quot; method=&quot;post&quot;&amp;gt; &amp;lt;label asp-for=&quot;Message&quot;&amp;gt;Enter Message&amp;lt;/label&amp;gt; &amp;lt;br /&amp;gt; &amp;lt;input type=&quot;text&quot; asp-for=&quot;Message&quot; /&amp;gt; &amp;lt;br /&amp;gt; &amp;lt;button type=&quot;submit&quot;&amp;gt;Submit&amp;lt;/button&amp;gt;&amp;lt;/form&amp;gt;HTML 태그로 입력 폼을 작성한 것인데 submit 버튼을 누르면 HomeController에 있는 Index()를 post 방식으로 호출하게 된다.추가적으로 _ViewImports.cshtml 파일을 추가해주어야하는데, ‘새 항목 추가 &amp;gt; Razor 뷰 가져오기’를 선택해서 생성하고 아래와 같이 작성해놓으면 된다._ViewImports.cshtml에 관한 설명@using HelloEmpty@using HelloEmpty.Models@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpersPOST 호출 처리View에서 post방식으로 Index()를 호출하는 부분이 있는데 이에 대해 Controller에서 처리를 해주어야 한다.이에 대한 처리를 간단하게 HomeController.cs에 추가해보자.public class HomeController : Controller { public IActionResult Index() { HelloMessage msg = new HelloMessage() { Message = &quot;Welcome to Asp.Net MVC !&quot; }; ViewBag.Noti = &quot;Input message and click submit&quot;; return View(msg); } // POST를 처리하는 Index [HttpPost] public IActionResult Index(HelloMessage obj) { ViewBag.Noti = &quot;Message Changed&quot;; return View(obj); } }POST를 처리하는 부분은 [HttpPost]를 붙여주어야한다.Startup마지막으로 방금 만들어준 View와 Controller를 내 웹서비스에 연결시켜주어야 한다. Startup.cs에서 이에 대한 설정을 할 수 있다.기존 코드에서 몇가지만 수정해보자.public class Startup{ // This method gets called by the runtime. Use this method to add services to the container. // For more information on how to configure your application, visit https://go.microsoft.com/fwlink/?LinkID=398940 public void ConfigureServices(IServiceCollection services) { services.AddControllersWithViews(); } // This method gets called by the runtime. Use this method to configure the HTTP request pipeline. public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } app.UseRouting(); app.UseEndpoints(endpoints =&amp;gt; { endpoints.MapControllerRoute( name: &quot;default&quot;, pattern: &quot;{controller=Home}/{action=Index}/{id?}&quot;); }); }}수정한 부분만 간단하게 살펴보자면public void ConfigureServices(IServiceCollection services){ services.AddControllersWithViews();}services.AddControllersWithViews(); 부분은 말그대로 MVC에서의 Controllers와 Views를 사용하겠다라는 의미이다.app.UseEndpoints(endpoints =&amp;gt;{ endpoints.MapControllerRoute( name: &quot;default&quot;, pattern: &quot;{controller=Home}/{action=Index}/{id?}&quot;);});EndPoints를 연동시켜주는 부분인데 쉽게 말하자면 웹페이지에서 어떤 주소를 입력하였을 때 어떤 애로 연동시켜줄 것인지 매핑해주는 부분이라고 생각하면 된다.코드에서 특히 pattern 부분이 중요한데 기본값이 /Home/Index이고 앞에부분을 Controller로 뒷부분을 action으로 인식하여 연동시켜주겠다는 의미이다.이대로 실행시켜보면 아래와 같은 페이지의 모습이 뜰 것이다. 또한 중앙에 아무 문자열을 입력하고 submit을 눌려보면 페이지속 Message가 바뀌는 것을 볼 수 있다.첫 실행화면Hello!라고 입력한 후 submit을 누른 화면동작 과정을 잠깐 정리해 보자면 ASP.NET Core 또한 콘솔 프로그램이라고 하였고 실행시키면 Main() 함수가 호출되면서 Startup 함수들을 호출해 준다. Startup에선 Controllers와 Views를 연동해 주는 등 이런저런 설정들을 해주고 사용자가 ‘{웹서버주소}/Home/Index’(Home/Index의 경우 생략 가능) 식으로 주소를 입력하면 Home은 controller, Index는 action으로 인식하여 HomeController 안의 Index()를 호출해 준다. 그러고는 Views/Home/Index.cshtml 파일을 읽어 사용자에게 보여준다." }, { "title": "[ASP.NET Core] Hello MVC #1", "url": "/posts/HelloMVC-1/", "categories": "웹 서버, ASP.NET Core 둘러보기", "tags": "MVC", "date": "2022-03-02 14:59:00 +0900", "snippet": "ASP.NET Core 소개ASP.NET Core는 Microsoft에서 개발한 웹 프레임워크이다. 할 수 있는 작업으로는 C#으로 웹앱 및 서비스 등을 빌드할 수 있으며, Blazor를 사용하면 C#으로 웹 프론트엔드까지 작업이 가능하다.ASP.NET Core로 작업할 수 있는 프로젝트 형태는 아래와 같다. MVC Razor Pages WebAPI Blazor Server Blazor ClientMVCMVC는 Model View Controller의 약자로 애플리케이션을 세가지 역할로 구분한 디자인 패턴이다. Model은 데이터를 어떻게 정의하고 관리할 것인지를 담당하고, View는 사용자에게 시각적으로 어떻게 보여줄 것인지를 담당하고, Controller는 동작에 관한 부분을 담당한다. M (Model) - 데이터 V (View) - UI C (Controller) - 동작MVC 프로젝트 생성Visual Studio에서 ‘새 프로젝트 생성 &amp;gt; ASP.NET Core 웹 애플리케이션 &amp;gt; 웹 응용 프로그램(모델-뷰-컨트롤러)’를 선택해 MVC 프로젝트를 생성해 볼 수 있다.프로젝트를 열어보면 Controllers, Models, Views로 구분되어 관리되고 있는 것을 볼 수 있으며, Program.cs를 열어보면 Main함수가 있는 것을 볼 수 있다. 이는 우리가 프로그래밍 언어를 배울 때 많이 보던 형식으로 ASP.NET Core 프로젝트 또한 콘솔 프로그램이라는 것을 의미한다.MVC 프로젝트 구조이대로 컴파일하여 실행시켜보면 아래와 같은 웹페이지가 뜰 것이다.ASP.NET Core MVC 웹페이지 화면" }, { "title": "[멀티쓰레드] Interlocked", "url": "/posts/Interlocked/", "categories": "서버, 멀티쓰레드 프로그래밍", "tags": "경쟁상태, Race Condition, Interlocked, 원자성, Atomic", "date": "2022-02-23 14:41:00 +0900", "snippet": "경쟁 상태(Race Condition)경쟁 상태(Race Condition)란 두 개 이상의 프로세스 또는 쓰레드가 하나의 공유 자원에 동시에 접근하여 결과값에 영향을 줄 수 있는 상태를 말한다.경쟁 상태(Race Condition) 예static int number = 0;static void Thread_1(){ for (int i = 0; i &amp;lt; 100000; i++) number++;}static void Thread_2(){ for (int i = 0; i &amp;lt; 100000; i++) number--;}static void Main(String[] args){ Task t1 = new Task(Thread_1); Task t2 = new Task(Thread_2); t1.Start(); t2.Start(); Task.WaitAll(t1, t2); Console.WriteLine(number);}위 코드를 보면 Thread_1에서는 number를 1씩 100000번 증가시켜주고 있고 Thread_2에서는 number를 1씩 100000번 감소해주고 있기 때문에 최종적으로 number는 0이 될것이라고 예상할 수 있다.그러나 실행시켜보면 0이 아닌 다른 값이 나온다.24632예상 결과와 다른 값이 나오는 이유는 두 쓰레드가 number라는 공유 자원에 동시에 접근하면서 Race Condition이 발생하였기 때문이다.자세한 부분은 number++와 number–하는 과정에서 찾아볼 수 있다. 우리가 사용한 number++이 실제 어셈블리어로 동작하는 과정을 보면 아래와 같다.00007FFDBB551513 mov ecx,dword ptr [7FFDBB5EFC0Ch] ; 데이터를 불러와서 ecx에 저장00007FFDBB551519 inc ecx ; ecx에 있는 값 1증가00007FFDBB55151B mov dword ptr [7FFDBB5EFC0Ch],ecx ; 아까 불러온 위치에 ecx에 있는 값 다시 저장//의사 코드int temp = number;temp = temp + 1;number = temp;우리가 볼 땐 한 줄짜리 코드지만 실제로는 위와 같이 처리된다. 그렇기에 number++과 number–이 거의 동시에 실행하게 된다면// 초기 상태 number = 0Thread_1 : int temp1 = number; // temp1 = 0Thread_1 : temp1 = temp1 + 1; // temp1 = 1Thread_2 : int temp2 = number; // temp2 = 0Thread_2 : temp2 = temp2 - 1; // temp2 = -1Thread_1 : number = temp1; // number = 1Thread_2 : number = temp2; // number = -1위와 같이 최종 number가 0이 아닌 값이 나올 수 있게 된다.일단 위 문제는 Interlocked를 사용하여 해결해 볼 수 있다.InterlockedInterlocked는 C#에서 지원해주고 있는 기능이며, 멀티쓰레드에서 공유하고 있는 변수에 대한 연산에 원자성(Atomic)을 보장해준다.여기서 원자성(Atomic)이란 더이상 쪼갤 수 없다라는 의미로 더 이상 과정이 쪼개지지 않고 한 번에 실행되는 것을 보장해주는 것을 말한다.Interlocked 사용법static int number = 0;static void Thread_1(){ for (int i = 0; i &amp;lt; 100000; i++) Interlocked.Increment(ref number); // 1 증가}static void Thread_2(){ for (int i = 0; i &amp;lt; 100000; i++) Interlocked.Decrement(ref number); // 1 감소}static void Main(String[] args){ Task t1 = new Task(Thread_1); Task t2 = new Task(Thread_2); t1.Start(); t2.Start(); Task.WaitAll(t1, t2); Console.WriteLine(number);}0아까 코드에서 number++과 number– 대신 Interlocked를 사용하여 1 증가, 감소를 해주고 있다.앞에 문제에선 number++ 또는 number– 하는 과정에서 다른 쓰레드가 끼어들어 Race Condition이라는 문제가 발생한 것인데, 여기에서는 Interlocked를 사용하여 원자성(Atomic)을 보장받고 있기 때문에 1 증가 또는 감소하는 과정에서 다른 쓰레드가 끼어들지 못해 결과에 문제없음을 볼 수 있다." }, { "title": "[멀티쓰레드] 메모리 배리어", "url": "/posts/%EB%A9%94%EB%AA%A8%EB%A6%AC%EB%B0%B0%EB%A6%AC%EC%96%B4/", "categories": "서버, 멀티쓰레드 프로그래밍", "tags": "메모리 배리어, Memory Barrier, 하드웨어 최적화, 가시성", "date": "2022-02-23 14:41:00 +0900", "snippet": "메모리 배리어메모리 배리어(Memory Barrier)는 하드웨어(CPU)나 컴파일러에게 특정 연산의 순서를 강제하도록 하는 기능이다.하드웨어(CPU)나 컴파일러에서는 최적화를 위해 연산 결과에 영향이 가지 않을 정도로 연산의 순서를 뒤바꿀수 있는데 멀티쓰레드 환경에서는 이러한 최적화로 인해 문제가 발생할 수 있다.하드웨어(CPU) 최적화 문제static int x = 0;static int y = 0;static int r1 = 0;static int r2 = 0;static void Thread_1(){ y = 1; // Store y r1 = x; // Load x}static void Thread_2(){ x = 1; // Store x r2 = y; // Load y}static void Main(String[] args){ int count = 0; while(true) { count++; x = y = r1 = r2 = 0; Task t1 = new Task(Thread_1); Task t2 = new Task(Thread_2); t1.Start(); t2.Start(); Task.WaitAll(t1, t2); if (r1 == 0 &amp;amp;&amp;amp; r2 == 0) break; } Console.WriteLine($&quot;{count}번만에 빠져나옴!&quot;);}위 코드를 보면 Thread_1과 Thread_2를 수행한 후 r1과 r2가 0인 경우에만 while문을 빠져나올 수 있다. 그러나 코드를 좀만 더 자세히 살펴본다면 r1과 r2가 동시에 0일 수가 없기 때문에 while문을 빠져나오지 못해야 정상이다.하지만 실행시켜보면 의외로 금방 빠져나오는 것을 볼 수 있다.23번만에 빠져나옴!while문을 빠져나오지 못해야 정상이지만 이러한 현상이 발생하는 이유는 하드웨어(CPU)에서는 연산 처리를 효율적으로 하기 위해 y = 1;과 r1 = x;의 순서를 뒤바꿀 수 있기 때문이다.(Thread_2도 마찬가지)싱글쓰레드에서는 y = 1;과 r1 = x;의 순서를 뒤바꿔도 결과에는 아무런 영향이 없기 때문에 최적화를 위해서 바뀌어도 상관없지만 멀티쓰레드 환경에서는 위와 같은 문제가 발생할 수 있다.이러한 문제를 방지하기 위해 메모리 배리어를 사용할 수 있다.메모리 배리어 사용법메모리 배리어는 아래와 같이 사용할 수 있다.static void Thread_1(){ y = 1; // Store y Thread.MemoryBarrier(); // 메모리 배리어 r1 = x; // Load x}static void Thread_2(){ x = 1; // Store x Thread.MemoryBarrier(); // 메모리 배리어 r2 = y; // Load y}위와 같이 메모리 배리어를 사용하면 y = 1;은 메모리 배리어 아래로 넘어가지 못하고 r1 = x;는 메모리 배리어 위로 넘어가지 못한다. 이로 인해 두 코드의 순서를 강제할 수 있게 된다. (Thread_2도 마찬가지)메모리 배리어를 사용하여 아까 코드를 실행시켜보면 while문을 빠져나오지 못하는 것을 볼 수 있다.메모리 배리어 종류 Full Memory Barrier - Store와 Load 둘다 막는다. 어셈블리어 - MFENCE C# - Thread.MemoryBarrier() Store Memory Barrier - Store만 막는다. 어셈블리어 - SFENCE Load Memory Barrier - Load만 막는다. 어셈블리어 - LFENCE 가시성메모리 배리어는 코드 순서를 강제하는 용도로도 사용할 수 있지만 가시성을 위해서도 사용할 수 있다.CPU에는 코어가 여러개 있고 각 코어들마다 캐시를 들고 있기에 이론상 동일한 변수라고 해도 코어들마다 다른 값을 가지고 있을 수 있다. 그렇기에 값이 바뀌면 메모리에 갱신하거나 최신 값을 불러와야하는데 메모리 배리어가 이러한 용도로도 사용할 수 있다.(요즘 CPU에서는 이러한 문제가 거의 발생하지 않는다.)메모리 배리어를 직접적으로 사용할 일은 거의 없겠지만 간접적으로 사용될 경우는 많기 때문에 원리라도 잘 이해하고 있는 것이 좋다." }, { "title": "[멀티쓰레드] 캐시 이론", "url": "/posts/%EC%BA%90%EC%8B%9C%EC%9D%B4%EB%A1%A0/", "categories": "서버, 멀티쓰레드 프로그래밍", "tags": "캐시, 지역성, cache, locality", "date": "2022-02-19 13:57:00 +0900", "snippet": "컴퓨터 구조 원리 - 캐시(cache)컴퓨터 구조 - 캐시캐시(cache)는 데이터를 미리 복사해 놓는 임시 장소로, 데이터에 접근하는 시간을 줄이기 위해 사용된다.컴퓨터는 기본적으로 프로그램을 메모리(RAM)에 올려놓고 실행시키지만 매번 메모리(RAM)에 접근하고 갱신하기에는 오래 걸리기에 연산장치와 메모리(RAM) 사이에 캐시장치를 두어 필요한 데이터를 미리 복사해 놓고 사용한다.캐시 철학(지역성의 원리)캐시는 효율적으로 동작하기 위해 지역성의 원리를 사용하는데 지역성이란 데이터 접근이 시간적 혹은 공간적으 가깝게 일어나는 것을 의미한다. 시간 지역성(Temporal locality) - 최근에 접근한 데이터가 잠시 후 한번 더 접근할 가능성이 높다. 공간 지역성(Spatial locality) - 방금 접근한 데이터와 인접한 데이터가 잠시 후 접근할 가능성이 높다. 이러한 지역성의 원리를 사용해 필요해질 것 같은 데이터들을 미리 복사해온다.지역성 테스트간단하게 캐시가 잘 동작하고 있는지 확인해 볼 수 있다.int[,] arr = new int[10000, 10000];long start, end;start = DateTime.Now.Ticks;for (int i = 0; i &amp;lt; 10000; i++) for (int j = 0; j &amp;lt; 10000; j++) arr[i, j] = 1;end = DateTime.Now.Ticks;Console.WriteLine($&quot;[i, j] 순서 걸린 시간 {end - start}&quot;);start = DateTime.Now.Ticks;for (int i = 0; i &amp;lt; 10000; i++) for (int j = 0; j &amp;lt; 10000; j++) arr[j, i] = 1;end = DateTime.Now.Ticks;Console.WriteLine($&quot;[j, i] 순서 걸린 시간 {end - start}&quot;);[i, j] 순서 걸린 시간 3280550[j, i] 순서 걸린 시간 5786319위 코드를 실행시켜보면 똑같은 구문인것 같지만 걸리는 시간이 거의 2배 가까이 차이나는 것을 볼 수 있다. 결과적으로는 2차원배열에 접근한다라는 것은 같지만 두 구문의 차이는 접근 순서에 있다.배열의 크기를 4 * 4라고 가정하고 접근 순서를 간단하게 표현해보자면첫 번째 [i, j] 순서는 배열을 메모리 주소대로 나열하였을 때 순차적으로 접근하지만 [1][2][3][4]   [5][6][7][8]   [9][10][11][12]   [13][14][15][16]두 번째 [j, i] 순서는 띄엄띄엄 접근한다라는 것을 알 수 있다. [1][5][9][13]   [2][6][10][14]   [3][7][11][15]   [4][8][12][16]앞에 지역성에서 공간 지역성이 있었는데 여기서 공간 지역성을 확인해 볼 수 있다. 공간 지역성에 따르면 배열에서의 첫 번째 메모리에 접근할 때 주변 인접한 메모리들까지 캐시에 복사해오는데, [i, j] 순서의 경우 인접한 순서대로 접근하였기에 캐시를 충분히 잘 활용할 수 있었고 [j, i] 순서의 경우 캐시를 제대로 활용하지 못해 앞에 보다 수행시간이 더 오래걸렸음을 알 수 있다." }, { "title": "[고급 C#] LINQ #2", "url": "/posts/LINQ-2/", "categories": "웹 서버, 고급 C# 문법", "tags": "LINQ", "date": "2022-02-18 14:42:00 +0900", "snippet": "LINQ 문법 정리기본적인 문법(from, where, orderby, select)from 어떤 데이터에서 찾을 것인지 where 어떤 조건으로 찾을 것인지 orderby 어떤 항목을 기준으로 정렬할 것인지 select 어떤 항목을 추출할 것인지public enum ClassType{ Knight, Archer, Mage}public class Player{ public ClassType classType { get; set; } public int Level { get; set; } public int Hp { get; set; } public int Attack { get; set; } public List&amp;lt;int&amp;gt; Items { get; set; } = new List&amp;lt;int&amp;gt;();}class Program{ static List&amp;lt;Player&amp;gt; _players = new List&amp;lt;Player&amp;gt;(); static void Main(String[] args) { Random rand = new Random(); // player 데이터 100개 랜덤 생성 for (int i = 0; i &amp;lt; 100; i++) { ClassType type = ClassType.Knight; switch (rand.Next(0, 3)) { case 0: type = ClassType.Knight; break; case 1: type = ClassType.Archer; break; case 2: type = ClassType.Mage; break; } Player player = new Player() { classType = type, Level = rand.Next(1, 10), Hp = rand.Next(100, 1000), Attack = rand.Next(5, 50) }; for (int j = 0; j &amp;lt; 5; j++) player.Items.Add(rand.Next(1, 101)); _players.Add(player); } //LINQ 사용 // 레벨이 50 이상인 Knight만 추려내서, 레벨 오름차순으로 정렬 var players = from p in _players where p.classType == ClassType.Knight &amp;amp;&amp;amp; p.Level &amp;gt;= 50 orderby p.Level ascending select p; foreach (Player p in players) { Console.WriteLine($&quot;{p.Level} {p.Hp}&quot;); } }}중첩 from이중 foreach문과 유사하다.// 아이템id가 30미만인 모든 아이템 목록을 추출var playerItems = from p in _players from i in p.Items where i &amp;lt; 30 select new { p, i };var li = playerItems.ToList();LINQ 중첩 fromgrouping데이터들을 그룹화하여 추출이 가능하다.// 레벨별로 그룹화하여 추출var playersByLevel = from p in _players group p by p.Level into g orderby g.Key select new { g.Key, Players = g };LINQ groupingjoin두 데이터 리스트들을 join하여 추출이 가능하다.// 레벨이 1, 5, 9인 player 데이터만 추출List&amp;lt;int&amp;gt; levels = new List&amp;lt;int&amp;gt;() { 1, 5, 9 };var playerLevels = from p in _players join l in levels on p.Level equals l select p;LINQ joinLINQ 표준 연산자LINQ는 SQL과 비슷한 문법으로 사용할 수 있게 되어 있지만 다른 문법으로도 사용이 가능하다.var players = from p in _players where p.classType == ClassType.Knight &amp;amp;&amp;amp; p.Level &amp;gt;= 50 orderby p.Level ascending select p;var players2 = _players .Where(p =&amp;gt; p.classType == ClassType.Knight &amp;amp;&amp;amp; p.Level &amp;gt;= 50) .OrderBy(p =&amp;gt; p.Level) .Select(p =&amp;gt; p);위 코드에서의 두 문법은 똑같이 동작한다. 우리가 SQL과 비슷한 문법으로 작성하더라도 실질적으로는 위와 같이 메소드 형태로 동작한다. 둘 다 알아놓는 것이 좋고 이외 많은 기능들이 있지만 필요할 때마다 찾아 사용하면 된다." }, { "title": "[고급 C#] LINQ #1", "url": "/posts/LINQ-1/", "categories": "웹 서버, 고급 C# 문법", "tags": "LINQ", "date": "2022-02-17 17:30:00 +0900", "snippet": "LINQC#에서는 LINQ라는 기능을 지원해주고 있다. LINQ는 “Language-Integrated Query”의 약자로, Query를 통해 원하는 데이터를 빠르고 편리하게 추출 할 수 있는 기능이다. 데이터를 다룰 때 유용한 문법이며, SQL 문법과 비슷하다.보통 데이터들이 있을 때 거기서 특정 필요한 데이터만 추출 및 가공해서 사용해야 하는 경우가 있다. 이때 기본적으로 for, if 문으로도 할 수 있지만 LINQ를 사용할 경우 가독성을 높일 수 있고 빠르고 편리하게 사용할 수 있다.LINQ 사용법예를 들어 수많은 player들의 데이터들이 있다고 할 때 레벨이 50 이상이고 직업이 Knight인 player들만 오름차순(레벨)으로 정렬해서 가져와야 한다면기본 C# 문법으로만 처리(for, if 문)먼저 기본적인 C#문법으로만 처리해보자.public enum ClassType{ Knight, Archer, Mage}public class Player{ public ClassType classType { get; set; } public int Level { get; set; } public int Hp { get; set; } public int Attack { get; set; }}class Program{ static List&amp;lt;Player&amp;gt; _players = new List&amp;lt;Player&amp;gt;(); static void Main(String[] args) { Random rand = new Random(); // player 데이터 100개 랜덤 생성 for (int i = 0; i &amp;lt; 100; i++) { ClassType type = ClassType.Knight; switch (rand.Next(0, 3)) { case 0: type = ClassType.Knight; break; case 1: type = ClassType.Archer; break; case 2: type = ClassType.Mage; break; } Player player = new Player() { classType = type, Level = rand.Next(1, 100), Hp = rand.Next(100, 1000), Attack = rand.Next(5, 50) }; _players.Add(player); } // 레벨이 50 이상인 Knight만 추려내서, 오름차순(레벨)으로 정렬 List&amp;lt;Player&amp;gt; players = GetHighLevelKnights(); foreach(Player p in players) { Console.WriteLine($&quot;{p.Level} {p.Hp}&quot;); } } static List&amp;lt;Player&amp;gt; GetHighLevelKnights() { List&amp;lt;Player&amp;gt; players = new List&amp;lt;Player&amp;gt;(); foreach(Player player in _players) { if (player.classType != ClassType.Knight) continue; if (player.Level &amp;lt; 50) continue; players.Add(player); } players.Sort((a, b) =&amp;gt; { return a.Level - b.Level; }); return players; }}이때 원하는 데이터를 추출하는 부분은 GetHighLevelKnights()이다.static List&amp;lt;Player&amp;gt; GetHighLevelKnights(){ List&amp;lt;Player&amp;gt; players = new List&amp;lt;Player&amp;gt;(); foreach(Player player in _players) { if (player.classType != ClassType.Knight) continue; if (player.Level &amp;lt; 50) continue; players.Add(player); } players.Sort((a, b) =&amp;gt; { return a.Level - b.Level; }); return players;}지금은 간단한 처리만 해주고 있다보니 그렇게 막 복잡하지는 않지만 아무런 조건도 모른채로 이 코드만 보았을 때 어떤 데이터를 추출하고 있는지 한번에 해석하기는 쉽지 않을 것이다.LINQ를 사용하여 처리LINQ의 기본 문법은 아래와 같다.from 어떤 데이터에서 찾을 것인지 where 어떤 조건으로 찾을 것인지 orderby 어떤 항목을 기준으로 정렬할 것인지 select 어떤 항목을 추출할 것인지LINQ를 사용해서 위와 똑같은 작업을 해보자.public enum ClassType{ Knight, Archer, Mage}public class Player{ public ClassType classType { get; set; } public int Level { get; set; } public int Hp { get; set; } public int Attack { get; set; }}class Program{ static List&amp;lt;Player&amp;gt; _players = new List&amp;lt;Player&amp;gt;(); static void Main(String[] args) { Random rand = new Random(); // player 데이터 100개 랜덤 생성 for (int i = 0; i &amp;lt; 100; i++) { ClassType type = ClassType.Knight; switch (rand.Next(0, 3)) { case 0: type = ClassType.Knight; break; case 1: type = ClassType.Archer; break; case 2: type = ClassType.Mage; break; } Player player = new Player() { classType = type, Level = rand.Next(1, 100), Hp = rand.Next(100, 1000), Attack = rand.Next(5, 50) }; _players.Add(player); } // 레벨이 50 이상인 Knight만 추려내서, 레벨 오름차순으로 정렬 // LINQ 문법 var players = from p in _players where p.classType == ClassType.Knight &amp;amp;&amp;amp; p.Level &amp;gt;= 50 orderby p.Level ascending // ascending은 생략가능, 내림차순은 desecnding select p; foreach (Player p in players) { Console.WriteLine($&quot;{p.Level} {p.Hp}&quot;); } }}LINQ 부분을 보자면 이전 코드의 GetHighLevelKnights()부분과 같은 역할을 하고 있음을 알 수 있다.var players = from p in _players where p.classType == ClassType.Knight &amp;amp;&amp;amp; p.Level &amp;gt;= 50 orderby p.Level ascending // ascending은 생략가능, 내림차순은 desecnding select p;SQL을 배웠다면 SQL문법과 매우 비슷하기에 쉽게 사용할 수 있을 것이다. 또한 이전 코드에 비해 짧고 가독성이 좋아 데이터를 다룰 때 유용하게 사용할 수 있다." }, { "title": "[고급 C#] Async, Await", "url": "/posts/AsyncAwait/", "categories": "웹 서버, 고급 C# 문법", "tags": "동기, 비동기, Async, Await", "date": "2022-02-17 14:36:00 +0900", "snippet": "동기(Synchronous)와 비동기(Asynchronous)동기(Synchronous)란 동시에 일어난다는 의미로 한자리에서 요청과 동시에 결과가 일어난다. 그렇기에 결과가 발생해야지만 다음 동작을 수행할 수 있다.비동기(Asynchronous)란 동시에 일어나지 않는다는 의미로 요청과 결과가 한자리에서 동시에 일어나지 않을 수 있다. 그렇기에 결과가 아직 주어지지 않더라도 다음 동작을 수행할 수 있다.비동기적으로 처리할 경우 병렬적으로 처리할 수 있다는 장점이 있다.비동기가 멀티쓰레드와 비슷하게 동작하다보니 같은 것이라고 생각할 수 있는데 비동기와 멀티쓰레드는 다른 개념이다. 비동기라고 꼭 멀티쓰레드로 동작하는 것은 아니다. 예를 들자면 유니티에서의 코루틴(Coroutine) 또한 일종의 비동기라고 할 수 있지만 싱글쓰레드로 동작한다.Async, AwaitC#에서는 async와 await를 사용하여 비동기 프로그래밍을 할 수 있다.async와 await를 사용하기전 아래 코드를 실행시켜보자.static void TestAsync(){ Console.WriteLine(&quot;TestAsync start&quot;); Task t = Task.Delay(3000); // 복잡한 작업 또는 오래 기다려야 하는 작업 t.Wait(); Console.WriteLine(&quot;TestAsync end&quot;);}static void Main(String[] args){ TestAsync(); Console.WriteLine(&quot;while start&quot;); while(true) { }}TestAsync startTestAsync endwhile startTestAsync start가 출력된 후 3초 후에 TestAsync end와 while start가 순서대로 출력된다. Main함수에서 TestAsync()를 호출하면 TestAsync 함수 내의 모든 작업을 수행한 후에 Main함수로 넘어온다라는 것을 알 수 있다.만약 TestAsync 함수 내의 작업이 매우 오래 기다려야하는 작업이라면 그 작업이 완료될 때까지 Main함수에서는 기다리기만 해야 하고 다른 작업으로는 넘어가지 못한다. 기다리는 동안 다른 작업을 하고 있을 수 있다면 효율적일 것이라고 생각이 들것이다. 이때 할 수 있는 것이 비동기 프로그래밍이다.C#에서는 async와 await를 사용해 비동기 프로그래밍을 할 수 있으며 위 코드에 적용시켜보면 아래와 같다.static async Task TestAsync(){ Console.WriteLine(&quot;TestAsync start&quot;); // await의 오른쪽 작업이 끝날 때까지 기다리지만 코드 흐름은 밖으로 넘긴다. await Task.Delay(3000); // 복잡한 작업 또는 오래 기다려야 하는 작업 Console.WriteLine(&quot;TestAsync end&quot;);}static void Main(String[] args){ Task t = TestAsync(); Console.WriteLine(&quot;while start&quot;); while(true) { }}TestAsync startwhile startTestAsync endTestAsync start와 while start가 순서대로 출력되고 3초 후 TestAsync end가 출력된다. TestAsync함수 내의 작업이 다 끝나지 않았음에도 Main함수에서는 다음 작업으로 넘어간 것을 알 수 있다.await의 특징은 await의 오른쪽 작업이 끝날 때까지 기다리긴 하지만 코드 흐름은 밖으로 보내 그 동안 다른 처리를 할 수 있도록 해준다.그러면 작업을 완료한 후에 다음 작업은 누가 실행시켜주는 것일까await 밑에 중단점을 찍어 디버깅을 해보면 알 수 있다.중단점 지정쓰레드 확인여기에서는 작업자 쓰레드가 생성되어 실행해주고 있는 것을 알 수 있다. 위 경우에서는 멀티쓰레드로 동작하고 있긴하지만 꼭 모든 비동기가 멀티쓰레드로 동작하는 것은 아니다. 싱글 쓰레드가 다시 돌아와서 실행시켜 주는 경우도 있다.아까는 TestAsync함수에서만 await를 해주었는데 Main에서도 await를 해주면 어떻게 될까static async Task TestAsync(){ Console.WriteLine(&quot;TestAsync start&quot;); await Task.Delay(3000); // 복잡한 작업 또는 오래 기다려야 하는 작업 Console.WriteLine(&quot;TestAsync end&quot;);}static async Task Main(String[] args){ await TestAsync(); Console.WriteLine(&quot;while start&quot;); while(true) { }}TestAsync startTestAsync endwhile startTestAsync start가 출력되고 3초후에 TestAsync end와 while start가 순서대로 출력된다. await 동작방식을 이해하였다면 충분히 해석할 수 있다.추가적으로 async와 await를 사용할 때 경우에 따라 데이터를 반환에 줄 수 도 있다.static async Task&amp;lt;int&amp;gt; TestAsync(){ Console.WriteLine(&quot;TestAsync start&quot;); await Task.Delay(3000); Console.WriteLine(&quot;TestAsync end&quot;); return 1; // 결과 값 반환}static async Task Main(String[] args){ int ret = await TestAsync(); Console.WriteLine(ret); // 결과 값 출력 Console.WriteLine(&quot;while start&quot;); while(true) { }}TestAsync startTestAsync end1while startAsync, Await 참고Microsoft 문서를 보면 Async, Await에 대해 참고하기 좋다. https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/위 문서에서는 아침 식사를 만드는 과정을 비유하여 예제를 보여주고 있다.결과부터 말하자면,아침식사를 만드는 과정이 아래와 같다고 했을 때 Pour a cup of coffee. Heat up a pan, then fry two eggs. Fry three slices of bacon. Toast two pieces of bread. Add butter and jam to the toast. Pour a glass of orange juice.동기적으로 처리할 경우출처:동기적 처리30분이 걸리는 데 생각해보면 비효율적이라는 것을 알 수 있다. pan 데워지기를 기다리는 동안 바로 eggs와 bacon을 올리면되고 eggs와 bacon이 익기를 기다리는 동안 식빵을 토스트기에 넣어두면 되기 때문이다.이부분에 대해서 비동기적으로 처리할 경우출처:비동기적 처리15분만에 처리할 수 있다는 것을 보여주고 있다." }, { "title": "[웹 기초] CSS #2", "url": "/posts/CSS-2/", "categories": "웹 서버, 웹 기초(HTML, CSS)", "tags": "CSS", "date": "2022-02-14 18:15:00 +0900", "snippet": "CSS Box Modelhttps://www.w3schools.com/css/를 참고출처:CSS Box ModelCSS Box Model은 기본적으로 모든 HTML 요소들의 영역을 상자로 표현한 것을 말한다. 각 HTML 요소들의 영역은 Margin, Border, Padding, Content로 나뉜다. Content - 텍스트와 이미지 등이 표시되는 공간이다. Padding - Content와 Border 사이의 여백이다. Border - Padding과 Content를 둘러싸는 테두리이다. Margin - 테두리 밖의 여백이다.&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;style&amp;gt;div { background-color: lightgrey; width: 500px; border: 15px solid green; padding: 50px; margin: 20px;}&amp;lt;/style&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h3&amp;gt;Demonstrating the Box Model&amp;lt;/h3&amp;gt;&amp;lt;p&amp;gt;The CSS box model is essentially a box that wraps around every HTML element. It consists of: borders, padding, margins, and the actual content.&amp;lt;/p&amp;gt;&amp;lt;div&amp;gt;This text is the content of the box. We have added a 50px padding, 20px margin and a 15px green border. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.&amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;Demonstrating the Box ModelThe CSS box model is essentially a box that wraps around every HTML element. It consists of: borders, padding, margins, and the actual content.This text is the content of the box. We have added a 50px padding, 20px margin and a 15px green border. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.Box Model을 사용할 때 “border-bottom” 이런 식의 속성도 사용할 수 있다.&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;style&amp;gt;h3 { border-bottom: 1px solid black; padding-bottom: 10px;}&amp;lt;/style&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h3&amp;gt;The CSS Box Model&amp;lt;/h3&amp;gt;&amp;lt;p&amp;gt;In CSS, the term &quot;box model&quot; is used when talking about design and layout.&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;The CSS box model is essentially a box that wraps around every HTML element. It consists of: margins, borders, padding, and the actual content.&amp;lt;/p&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;The CSS Box ModelIn CSS, the term &quot;box model&quot; is used when talking about design and layout.The CSS box model is essentially a box that wraps around every HTML element. It consists of: margins, borders, padding, and the actual content." }, { "title": "[웹 기초] CSS #1", "url": "/posts/CSS-1/", "categories": "웹 서버, 웹 기초(HTML, CSS)", "tags": "CSS", "date": "2022-02-14 16:07:00 +0900", "snippet": "CSSCSS란 “Cascading Style Sheet”로 HTML 등의 마크업 언어로 작성된 문서가 실제로 웹사이트에 표현되는 방법을 정해주는 스타일시트 언어이다. 쉽게 말하면 웹페이지를 꾸며주는 언어이다.CSS를 학습할 때 아래 사이트를 참고하면 매우 좋다. https://www.w3schools.com/css/HTML tagsHTML에서는 아래와 같은 태그들로 CSS를 적용시킬 수 있다.&amp;lt;span&amp;gt;&amp;lt;span&amp;gt;은 텍스트의 일부나 문서의 일부에 style을 적용시키기 위한 태그이다.&amp;lt;p&amp;gt;My mother has &amp;lt;span style=&quot;color:blue&quot;&amp;gt;blue&amp;lt;/span&amp;gt; eyes.&amp;lt;/p&amp;gt;My mother has blue eyes.&amp;lt;span&amp;gt;이라는 tag를 이용해서 부분별로 style 속성을 지정 할 수 있지만 각 부분별로 일일이 style 속성을 지정하면 비효율적이면서 관리하기가 힘들다. 그렇기에 보통은 style 관련 부분은 따로 빼서 &amp;lt;style&amp;gt;이라는 태그에서 관리하거나 css파일을 만들어서 관리한다.&amp;lt;style&amp;gt;&amp;lt;style&amp;gt;은 CSS 부분을 정의하기 위한 태그이다.&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;style&amp;gt; h4 {color:red;} p {color:blue;}&amp;lt;/style&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h4&amp;gt;A heading&amp;lt;/h4&amp;gt;&amp;lt;p&amp;gt;A paragraph.&amp;lt;/p&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;A headingA paragraph.해당 웹페이지에 적용될 CSS부분을 따로 정의 및 관리할 수 있다. CSS 파일로 따로 빼서 관리한다면 다른 웹페이지에서도 적용시킬 수 있다.CSS Syntax(문법)출처:CSS SyntaxCSS 문법은 기본적으로 위 형태로 동일하다.Selector부분은 style을 지정할 요소를 말한다.중괄호안에는 “속성:값;” 형태로 style을 지정해준다.쉽게 말하자면 CSS 문법은 누구(Selector)한테 무엇(Property)을 어떻게(Value) 적용할 것인가를 표현한 것이다.CSS SelectorsCSS 문법은 위가 다지만 Selector를 지정하는 방법이 여러가지가 있다.element SelectorHTML 요소(tag)에다 style을 적용시킬 수 있다.&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;style&amp;gt;p { text-align: center; color: red;}&amp;lt;/style&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;p&amp;gt;Every paragraph will be affected by the style.&amp;lt;/p&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;Every paragraph will be affected by the style.id SelectorHTML 요소(tag)의 id 속성을 사용하여 하나의 고유한 요소에 style을 적용시킬 수 있다.&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;style&amp;gt;#para1 { text-align: center; color: red;}&amp;lt;/style&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;p id=&quot;para1&quot;&amp;gt;Hello World!&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;This paragraph is not affected by the style.&amp;lt;/p&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;Hello World!This paragraph is not affected by the style.class Selector특정 class 속성을 가진 HTML 요소(tag)들에 style을 적용시킬 수 있다.&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;style&amp;gt;.center { text-align: center; color: red;}&amp;lt;/style&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h4 class=&quot;center&quot;&amp;gt;Red and center-aligned heading&amp;lt;/h4&amp;gt;&amp;lt;p class=&quot;center&quot;&amp;gt;Red and center-aligned paragraph.&amp;lt;/p&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;Red and center-aligned headingRed and center-aligned paragraph.Grouping SelectorStyle 정의가 동일한 요소들은 그룹화하여 적용시킬 수 있다.&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;style&amp;gt;h1, h2, p { text-align: center; color: red;}&amp;lt;/style&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;&amp;lt;h2&amp;gt;Smaller heading!&amp;lt;/h2&amp;gt;&amp;lt;p&amp;gt;This is a paragraph.&amp;lt;/p&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;Hello World!Smaller heading!This is a paragraph." }, { "title": "[멀티쓰레드] 컴파일러 최적화", "url": "/posts/%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC%EC%B5%9C%EC%A0%81%ED%99%94/", "categories": "서버, 멀티쓰레드 프로그래밍", "tags": "컴파일러 최적화, Release 모드", "date": "2022-02-11 17:08:00 +0900", "snippet": "컴파일러 최적화(Release 모드)간단한 멀티쓰레드 코드를 작성해보자.static bool _stop = false; // 전역 변수는 쓰레드 간 공유된다.static void Thread1(){ Console.WriteLine(&quot;쓰레드 시작!&quot;); while(_stop == false) { // 누군가가 stop 신호를 해주기를 기다린다. } Console.WriteLine(&quot;쓰레드 종료!&quot;);}static void Main(String[] args){ Task t = new Task(Thread1); t.Start(); Thread.Sleep(1000); // 1초 대기 _stop = true; Console.WriteLine(&quot;Stop 호출&quot;); Console.WriteLine(&quot;종료 대기중&quot;); t.Wait(); // Thread1이 종료될때까지 기다린다. Console.WriteLine(&quot;종료 성공&quot;);}정상 실행이 된다면 아래와 같이 결과가 나타날 것이다.(마지막에 종료 성공이 떴다면 정상)쓰레드 시작!쓰레드 종료!Stop 호출종료 대기중종료 성공그러나 여기서 컴파일을 Debug에서 Release 모드로 변경하여 컴파일을 한다면 어떻게 될까.Release모드 선택 방법Release 모드로 컴파일했을 경우 실행 결과(상황에 따라 다를 수 있음)쓰레드 시작!Stop 호출종료 대기중종료 대기중에서 더이상 넘어가지 않는 것을 볼 수 있다.이러한 현상이 발생하는 이유는 컴파일러 최적화하는 과정에 있다. Release 모드는 보통 프로그램 개발이 완료되어 최종 배포할 때 사용하는데 컴파일할 때 여러 최적화가 이루어져 프로그램이 빠르게 실행되도록 한다. 그러나 최적화 하는 과정에서 의도했던 것과 다르게 바뀔수도 있다.위 코드에서 while문 부분에 중단점을 걸어놓고 Release모드 상태에서 디버깅을 돌려보자.(디버깅을 실행했을 때 경고창이 뜬다면 ‘[내 코드]는 사용 안 함 그리고 계속’을 선택해주면 된다.)while문에 중단점 지정디버깅 실행 후 중단점에서 멈추었다면 ‘디버그 -&amp;gt; 창 -&amp;gt; 디스어셈블리’를 눌러보면 어셈블리어로 변형된 코드를 볼 수 있다.디스어셈블리 창어셈블리어를 모르더라도 while문 부분만 간단하게 해석해보자면00007FFC8EEB2D36 movzx ecx,byte ptr [7FFC8EF3FBF2h] ; 데이터를 불러와 ecx에 저장 while(_stop == false)00007FFC8EEB2D3D test ecx,ecx ; ecx가 0인지 1인지 검사00007FFC8EEB2D3F je serverTest.Program.Thread1()+01Dh (07FFC8EEB2D3Dh) ; 0이라면 바로 윗 줄로 이동ecx라는 레지스터에 어떠한 데이터를 꺼내와서 저장하고 ecx가 0인지 1인지 검사한 후 0이라면 다시 바로 윗 줄로 이동하여 반복한다. 결론은 ecx에 0(false)이 들어가있다면 무한 반복하게 되는 것이다.이해를 위해 의사코드로 나타내보면// 최적화하는 과정에서 변형된 코드(의사코드)if(_stop == false){ while(true) { }}// 처음 작성한 코드while(_stop == false){}최적화하는 과정에서 컴파일러는 이 코드가 멀티쓰레드 환경에서 실행된다라는 것을 고려하지 않고, 단순히 현재 코드를 보았을 때 어짜피 while문 안에서는 _stop 값을 변환해주지 않기 때문에 false인 경우 그냥 while(true)로 동작하도록 수정해버린 것이다.일단 위 문제에 대한 해결은 static bool _stop 앞에 volatile를 붙여주면 된다. volatile를 붙이면 휘발성이라는 의미로 언제 어떻게든 바뀔 수 있으니 최적화를 하지말라는 의미가 된다.volatile static bool _stop = false;static void Thread1(){ Console.WriteLine(&quot;쓰레드 시작!&quot;); while(_stop == false) { // 누군가가 stop 신호를 해주기를 기다린다. } Console.WriteLine(&quot;쓰레드 종료!&quot;);}static void Main(String[] args){ Task t = new Task(Thread1); t.Start(); Thread.Sleep(1000); _stop = true; Console.WriteLine(&quot;Stop 호출&quot;); Console.WriteLine(&quot;종료 대기중&quot;); t.Wait(); Console.WriteLine(&quot;종료 성공&quot;);}쓰레드 시작!Stop 호출종료 대기중쓰레드 종료!종료 성공volatile의 경우 다른 의미가 있기도 하지만 사실 잘 사용되지는 않고 보통 메모리 배리어나 lock, atomic과 같은 옵션들을 사용하기 때문에 크게 중요하지 않다. 그보다 중요한 것은 Release 모드에서는 컴파일러 최적화 때문에 일어나지 않던 문제가 발생할 수 있다는 점이다." }, { "title": "[웹 기초] HTML #5", "url": "/posts/HTML-5/", "categories": "웹 서버, 웹 기초(HTML, CSS)", "tags": "HTML", "date": "2022-02-11 15:04:00 +0900", "snippet": "HTML 입력 폼https://www.w3schools.com/tags/ 를 참고보통 어떤 웹 페이지에 처음 접속하여 가입하려 할 때 이름 및 아이디, 비밀번호 등을 입력하는 폼을 본 적이 있을 것이다. 이때 필요한 tag들을 살펴볼 것이다.&amp;lt;button&amp;gt;입력에 가장 많이 사용되는 것은 버튼일 것이다.&amp;lt;input&amp;gt;으로도 버튼을 만들 수 있지만, &amp;lt;button&amp;gt;은 버튼 전용 tag라고 생각하면 된다.&amp;lt;button type=&quot;button&quot; onclick=&quot;alert(&#39;Hello world!&#39;)&quot;&amp;gt;Click Me!&amp;lt;/button&amp;gt;Click Me!type 속성에 “button”을 지정하지 않아도 잘 작동하지만 type=”button”를 해주는 것이 권고사항이다.onclick 속성에는 javascript 코드가 들어가며 버튼을 클릭하였을 때 onclick에 지정된 코드가 실행된다. 참고로 코드부분을 따로 꺼내서 관리하는 것도 가능하다.&amp;lt;script&amp;gt; function testFunc() { alert(&#39;Hello world!&#39;) }&amp;lt;/script&amp;gt;&amp;lt;button type=&quot;button&quot; onclick=&quot;testFunc()&quot;&amp;gt;Click Me!&amp;lt;/button&amp;gt;Click Me!&amp;lt;button&amp;gt;과 &amp;lt;input&amp;gt;의 차이점은 &amp;lt;button&amp;gt;은 안에 다른 tag들을 포함할 수 있지만 &amp;lt;input&amp;gt;은 불가능하다.&amp;lt;button type=&quot;button&quot; onclick=&quot;alert(&#39;Hello world!&#39;)&quot;&amp;gt; &amp;lt;img src=&quot;/assets/img/posts/webserver/img_girl.jpg&quot; alt=&quot;Girl in a jacket&quot; width=&quot;100&quot; height=&quot;120&quot;&amp;gt;&amp;lt;/button&amp;gt; &amp;lt;input&amp;gt;사용자가 데이터를 입력할 수 있는 입력 필드를 지정한다.&amp;lt;input&amp;gt;은 type 속성에 따라 여러가지 방법으로 표시될 수 있다. &amp;lt;input type=”button”&amp;gt; &amp;lt;input type=”checkbox”&amp;gt; &amp;lt;input type=”color”&amp;gt; &amp;lt;input type=”date”&amp;gt; &amp;lt;input type=”datetime-local”&amp;gt; &amp;lt;input type=”email”&amp;gt; &amp;lt;input type=”file”&amp;gt; &amp;lt;input type=”hidden”&amp;gt; &amp;lt;input type=”image”&amp;gt; &amp;lt;input type=”month”&amp;gt; &amp;lt;input type=”number”&amp;gt; &amp;lt;input type=”password”&amp;gt; &amp;lt;input type=”radio”&amp;gt; &amp;lt;input type=”range”&amp;gt; &amp;lt;input type=”reset”&amp;gt; &amp;lt;input type=”search”&amp;gt; &amp;lt;input type=”submit”&amp;gt; &amp;lt;input type=”tel”&amp;gt; &amp;lt;input type=”text”&amp;gt;(기본값) &amp;lt;input type=”time”&amp;gt; &amp;lt;input type=”url”&amp;gt; &amp;lt;input type=”week”&amp;gt;다 외울 필요는 없고 필요할 때마다 찾아 사용하면 된다. &amp;lt;input&amp;gt;을 사용해 입력 폼을 간단히 만들어보면 다음과 같다.&amp;lt;h4&amp;gt;The input element&amp;lt;/h4&amp;gt;&amp;lt;form action=&quot;/action_page.php&quot;&amp;gt; &amp;lt;label for=&quot;fname&quot;&amp;gt;First name:&amp;lt;/label&amp;gt; &amp;lt;input type=&quot;text&quot; id=&quot;fname&quot; name=&quot;fname&quot;&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt; &amp;lt;label for=&quot;lname&quot;&amp;gt;Last name:&amp;lt;/label&amp;gt; &amp;lt;input type=&quot;text&quot; id=&quot;lname&quot; name=&quot;lname&quot;&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt; &amp;lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&amp;gt;&amp;lt;/form&amp;gt;&amp;lt;p&amp;gt;&quot;Submit&quot; 버튼을 클릭하면 양식 데이터가 &quot;action_page.php&quot;라는 서버의 페이지로 전송됩니다.&amp;lt;/p&amp;gt;The input element First name: Last name: &quot;Submit&quot; 버튼을 클릭하면 양식 데이터가 &quot;action_page.php&quot;라는 서버의 페이지로 전송됩니다.&amp;lt;form&amp;gt;은 &amp;lt;input&amp;gt;과 &amp;lt;button&amp;gt; 등을 그룹화하여 하나의 폼으로 관리하기 위한 tag이고, &amp;lt;label&amp;gt;은 각 요소에 어떠한 요소인지 정의해주는 역할을 한다. &amp;lt;label&amp;gt;을 사용할 때는 for 속성을 해당 요소의 id 속성과 같게 지정해주어야 한다.(for 속성과 id 속성이 같아야 함께 바인딩이 된다.)&amp;lt;h4&amp;gt;The label element&amp;lt;/h4&amp;gt;&amp;lt;p&amp;gt;Click on one of the text labels to toggle the related radio button:&amp;lt;/p&amp;gt;&amp;lt;form action=&quot;/action_page.php&quot;&amp;gt;  &amp;lt;input type=&quot;radio&quot; id=&quot;html&quot; name=&quot;fav_language&quot; value=&quot;HTML&quot;&amp;gt;  &amp;lt;label for=&quot;html&quot;&amp;gt;HTML&amp;lt;/label&amp;gt;&amp;lt;br&amp;gt;  &amp;lt;input type=&quot;radio&quot; id=&quot;css&quot; name=&quot;fav_language&quot; value=&quot;CSS&quot;&amp;gt;  &amp;lt;label for=&quot;css&quot;&amp;gt;CSS&amp;lt;/label&amp;gt;&amp;lt;br&amp;gt;  &amp;lt;input type=&quot;radio&quot; id=&quot;javascript&quot; name=&quot;fav_language&quot; value=&quot;JavaScript&quot;&amp;gt;  &amp;lt;label for=&quot;javascript&quot;&amp;gt;JavaScript&amp;lt;/label&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt; &amp;lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&amp;gt;&amp;lt;/form&amp;gt;The label elementClick on one of the text labels to toggle the related radio button:    HTML    CSS    JavaScript " }, { "title": "[웹 기초] HTML #4", "url": "/posts/HTML-4/", "categories": "웹 서버, 웹 기초(HTML, CSS)", "tags": "HTML", "date": "2022-02-10 17:25:00 +0900", "snippet": "HTML 구조https://www.w3schools.com/tags/ 를 참고HTML로 작성할 때 기본적으로 들어가는 요소들이 있다. 한 가지씩 살펴보자면&amp;lt;!DOCTYPE&amp;gt; 선언기본적으로 HTML 파일은 &amp;lt;!DOCTYPE html&amp;gt;으로 시작해야 한다.이것은 HTML 파일이다라는 것을 의미하며, 이것이 없어도 동작하긴하지만 기본적으로 권고사항이라고 생각하면 된다.&amp;lt;html&amp;gt;&amp;lt;html&amp;gt; 태그는 HTML 코드 부분을 의미한다. 모든 HTML 코드는 &amp;lt;html&amp;gt; 태그 안에 포함시키면 된다.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt; &amp;lt;!-- html 코드 --&amp;gt;&amp;lt;\\html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;body&amp;gt;&amp;lt;head&amp;gt;는 웹 페이지의 metadata(데이터에 대한 데이터) 부분을 의미하고, &amp;lt;body&amp;gt;는 그외 모든 내용을 포함하는 부분이라고 생각하면 된다.&amp;lt;head&amp;gt;안에는 &amp;lt;title&amp;gt;, &amp;lt;\\style&amp;gt;, &amp;lt;\\meta&amp;gt; 등이 들어갈 수 있다.&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;!-- html 파일임을 명시 --&amp;gt;&amp;lt;html&amp;gt; &amp;lt;!-- html 코드 부분 --&amp;gt; &amp;lt;head&amp;gt; &amp;lt;!-- 웹 페이지의 metadata 부분 --&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;!-- UTF-8 인코딩 방식을 사용한다는 의미--&amp;gt; &amp;lt;title&amp;gt;웹 페이지 타이틀&amp;lt;/title&amp;gt; &amp;lt;style&amp;gt; /* CSS 코드 */ &amp;lt;/style&amp;gt; &amp;lt;!-- 그외 metadata들 --&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;!-- contents 부분 --&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;lt;div&amp;gt;아무 웹페이지에 들어가 F12를 누르면 해당 웹페이지의 HTML코드를 볼 수 있는데 &amp;lt;div&amp;gt;라는 tag가 가장 많이 보이는 것을 알 수 있다. &amp;lt;div&amp;gt;는 영역을 구분하는 용도로 사용되는데, 영역별로 구분해서 style을 지정해주기 위해 사용된다.&amp;lt;div&amp;gt;는 보통 class와 id 속성을 사용하여 style 지정을 한다.&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;style&amp;gt; .myDiv { border: 5px outset red; background-color: lightblue; text-align: center; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div class=&quot;myDiv&quot;&amp;gt; &amp;lt;h1&amp;gt;This is a heading in a div element&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;This is some text in a div element.&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt; This is a heading in a div element This is some text in a div element.HTML 기본적인 구조&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;!-- html 파일임을 명시 --&amp;gt;&amp;lt;html&amp;gt; &amp;lt;!-- html 코드 부분 --&amp;gt; &amp;lt;head&amp;gt; &amp;lt;!-- 웹 페이지의 metadata 부분 --&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;!-- UTF-8 인코딩 방식을 사용한다는 의미--&amp;gt; &amp;lt;title&amp;gt;웹 페이지 타이틀&amp;lt;/title&amp;gt; &amp;lt;style&amp;gt; /* CSS 코드 */ &amp;lt;/style&amp;gt; &amp;lt;!-- 그외 metadata들 --&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;!-- contents 부분 --&amp;gt; &amp;lt;div&amp;gt; &amp;lt;!-- &amp;lt;div&amp;gt;로 영역 구분(영역별로 style 지정) --&amp;gt; &amp;lt;!-- ... --&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- ... --&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;" }, { "title": "[웹 기초] HTML #3", "url": "/posts/HTML-3/", "categories": "웹 서버, 웹 기초(HTML, CSS)", "tags": "HTML", "date": "2022-02-10 15:28:00 +0900", "snippet": "HTML tagshttps://www.w3schools.com/tags/ 를 참고리스트 표현 &amp;lt;ol&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;&amp;lt;ol&amp;gt; &amp;lt;li&amp;gt;Coffee&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;Tea&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;Milk&amp;lt;/li&amp;gt;&amp;lt;/ol&amp;gt;&amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;Coffee&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;Tea&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;Milk&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt; Coffee Tea Milk Coffee Tea Milk&amp;lt;ol&amp;gt; - 순서가 있는 목록(ordered list) &amp;lt;ul&amp;gt; - 순서가 없는 목록(unordered list) &amp;lt;li&amp;gt; - 각 항목표 표현 &amp;lt;table&amp;gt;기본 요소 &amp;lt;tr&amp;gt; &amp;lt;th&amp;gt; &amp;lt;td&amp;gt;&amp;lt;table&amp;gt;은 HTML table을 나타낸다. HTML table은 기본적으로 &amp;lt;\\tr&amp;gt;, &amp;lt;th&amp;gt;, &amp;lt;td&amp;gt; 요소로 구성된다.&amp;lt;table&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;th&amp;gt;Month&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;Savings&amp;lt;/th&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;January&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;$100&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;February&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;$80&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt;&amp;lt;/table&amp;gt; Month Savings January $100 February $80 &amp;lt;tr&amp;gt; - 각 행을 의미(table row) &amp;lt;th&amp;gt; - 해더 항목을 의미(table header) &amp;lt;td&amp;gt; - 데이터 항목을 의미(table data)혹시 표에 테두리가 보이게 하고 싶다면 나중에 CSS를 배울때 알게되겠지만 일단 아래와 같이 &amp;lt;style&amp;gt;를 적용해보면 된다.&amp;lt;style&amp;gt;table, th, td { border: 1px solid black;}&amp;lt;/style&amp;gt;&amp;lt;table&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;th&amp;gt;Month&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;Savings&amp;lt;/th&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;January&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;$100&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;February&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;$80&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt;&amp;lt;/table&amp;gt; Month Savings January $100 February $80 각 영역 지정 &amp;lt;thead&amp;gt; &amp;lt;tbody&amp;gt; &amp;lt;tfoot&amp;gt;HTML table에서는 추가적인 요소도 넣을 수 있는데 &amp;lt;thead&amp;gt;, &amp;lt;tbody&amp;gt;, &amp;lt;tfoot&amp;gt; 등이 있다.&amp;lt;table&amp;gt; &amp;lt;thead&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;th&amp;gt;Month&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;Savings&amp;lt;/th&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/thead&amp;gt; &amp;lt;tbody&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;January&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;$100&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;February&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;$80&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/tbody&amp;gt; &amp;lt;tfoot&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;Sum&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;$180&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/tfoot&amp;gt;&amp;lt;/table&amp;gt; Month Savings January $100 February $80 Sum $180 &amp;lt;thead&amp;gt;, &amp;lt;tbody&amp;gt;, &amp;lt;tfoot&amp;gt;은 표에서 각 부분(머리, 본문, 바닥) 영역을 지정해주기 위해 사용되며, 지금은 지정해도 별 차이가 안보일 수 있지만 나중에 각 영역별로 style을 지정해주거나 효과를 넣을 때 사용할 수 있다.&amp;lt;style&amp;gt;thead {color: green;}tbody {color: blue;}tfoot {color: red;}table, th, td { border: 1px solid black;}&amp;lt;/style&amp;gt;&amp;lt;table&amp;gt; &amp;lt;thead&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;th&amp;gt;Month&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;Savings&amp;lt;/th&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/thead&amp;gt; &amp;lt;tbody&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;January&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;$100&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;February&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;$80&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/tbody&amp;gt; &amp;lt;tfoot&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;Sum&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;$180&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/tfoot&amp;gt;&amp;lt;/table&amp;gt; Month Savings January $100 February $80 Sum $180 " }, { "title": "[웹 기초] HTML #2", "url": "/posts/HTML-2/", "categories": "웹 서버, 웹 기초(HTML, CSS)", "tags": "HTML", "date": "2022-02-08 18:21:00 +0900", "snippet": "HTML tagshttps://www.w3schools.com/tags/ 를 참고&amp;lt;br&amp;gt;줄 바꿈을 의미한다.To force&amp;lt;br&amp;gt; line breaks&amp;lt;br&amp;gt; in a text,&amp;lt;br&amp;gt; use the br&amp;lt;br&amp;gt; element.To force line breaks in a text, use the br element.다른 태그와 다르게 범위를 지정할 필요가 없기 때문에 &amp;lt;\\br&amp;gt;와 같은 끝 태그가 없다.&amp;lt;p&amp;gt;단락을 정의할 때 사용된다.&amp;lt;p&amp;gt;This is some text in a paragraph.&amp;lt;/p&amp;gt;This is some text in a paragraph.기본적으로 각 요소 앞과 뒤에 빈 줄 하나씩 추가되는 것을 볼 수 있다.&amp;lt;img&amp;gt;이미지를 삽입할 때 사용된다.&amp;lt;img src=&quot;/assets/img/posts/webserver/img_girl.jpg&quot; alt=&quot;Girl in a jacket&quot; width=&quot;300&quot; height=&quot;360&quot;&amp;gt;src=“이미지 파일 경로” alt=“이미지 파일을 못찾았을 때 표시할 텍스트” width=“이미지 너비” height=“이미지 높이”&amp;lt;a&amp;gt;다른 페이지로 연결되는 링크를 삽입할 때 사용된다. (하이퍼링크)&amp;lt;a href=&quot;https://www.naver.com&quot;&amp;gt;네이버 열기&amp;lt;/a&amp;gt;네이버 열기href=“링크” 기본적으로 연결된 페이지는 현재 브라우저 창에 표시된다.새 창으로 열고 싶을 경우&amp;lt;a href=&quot;https://www.naver.com&quot; target=&quot;_blank&quot;&amp;gt;새 창으로 네이버 열기&amp;lt;/a&amp;gt;새 창으로 네이버 열기이미지를 링크로 사용할 때&amp;lt;a href=&quot;https://www.naver.com&quot; target=&quot;_blank&quot;&amp;gt; &amp;lt;img src=&quot;/assets/img/posts/webserver/img_girl.jpg&quot; alt=&quot;Girl in a jacket&quot; width=&quot;300&quot; height=&quot;360&quot;&amp;gt;&amp;lt;/a&amp;gt; " }, { "title": "[웹 기초] HTML #1", "url": "/posts/HTML-1/", "categories": "웹 서버, 웹 기초(HTML, CSS)", "tags": "HTML", "date": "2022-02-08 16:19:00 +0900", "snippet": "HTMLHTML이란 “Hyper Text Markup Language”로 웹을 이루는 가장 기초적인 구성 요소이며, 웹의 구조를 정의할 때 사용된다. 쉽게 말하자면 웹페이지의 골격을 나타내주는 마크업 언어이다.HTML은 tag들로 이루어져 있으며, 골격들이라고 생각하면 된다. HTML을 학습할 때 아래 사이트를 참고하면 매우 좋다. https://www.w3schools.com/tags/ HTML tags들을 살펴볼 수 있으며, 각 tag들에 대한 사용법이나 예제들을 볼 수 있다. 또한 가장 좋은 점은 그 자리에서 바로 실행시켜 볼 수 있다는 점이다.HTML를 공부해보면 알겠지만 웹페이지도 하나의 문서 형태이기 때문에 워드나 한글로 문서 작성해보는 거랑 매우 비슷하다. HTML로 웹페이지를 만들어보면 제목과 본문이 있고 글자 굵게 또는 기울임, 밑줄 등 문서 편집기와 비슷한 기능들이 있다. 이에 웹페이지를 꾸며주는 기능을 하는 css가 추가되면 우리가 평소에 보는 웹페이지의 모습이 된다.몇가지 HTML tags들을 살펴보자면HTML tagshttps://www.w3schools.com/tags/ 를 참고&amp;lt;b&amp;gt;일부 텍스트를 굵게 표시한다.일부 텍스트를 &amp;lt;b&amp;gt;굵게&amp;lt;/b&amp;gt; 표시한다.&amp;lt;i&amp;gt;일부 텍스트를 기울임꼴로 표시한다.일부 텍스트를 &amp;lt;i&amp;gt;기울임꼴로&amp;lt;/i&amp;gt; 표시한다.&amp;lt;u&amp;gt;일부 텍스트에 밑줄 표시한다.일부 텍스트 &amp;lt;u&amp;gt;밑줄&amp;lt;/u&amp;gt; 표시한다.&amp;lt;strong&amp;gt;매우 중요한 텍스트를 정의할 때 사용된다. 기본적으로는 굵게 표시된다.&amp;lt;strong&amp;gt;매우 중요한 텍스트&amp;lt;/strong&amp;gt;를 정의할 때 사용된다.그냥 보면 &amp;lt;b&amp;gt;와 별 차이가 없는 것으로 보이는데 굳이 똑같은 기능을 하는 tag가 왜 2개나 있는지 궁금해 할 수 있다. 나중에 css를 배우거나 하면 알게되겠지만 tag마다 스타일을 지정하거나 효과를 지정할 수 있는데 지금은 효과가 같아보이지만 나중에 구분해서 효과를 줄 수 있다.보통 정말 중요한 텍스트는 &amp;lt;string&amp;gt;로 표시하고, 중요하지는 않지만 그냥 텍스트를 보기 좋게 하기 위할 때는 &amp;lt;b&amp;gt;로 표시한다.&amp;lt;h1&amp;gt; ~ &amp;lt;h6&amp;gt;제목을 정의할 때 사용된다. &amp;lt;h1&amp;gt;은 가장 큰 제목을 의미하고, &amp;lt;h6&amp;gt;은 가장 작은 제목을 의미한다.&amp;lt;h1&amp;gt;This is heading 1&amp;lt;/h1&amp;gt;&amp;lt;h2&amp;gt;This is heading 2&amp;lt;/h2&amp;gt;&amp;lt;h3&amp;gt;This is heading 3&amp;lt;/h3&amp;gt;&amp;lt;h4&amp;gt;This is heading 4&amp;lt;/h4&amp;gt;&amp;lt;h5&amp;gt;This is heading 5&amp;lt;/h5&amp;gt;&amp;lt;h6&amp;gt;This is heading 6&amp;lt;/h6&amp;gt;This is heading 1This is heading 2This is heading 3This is heading 4This is heading 5This is heading 6" }, { "title": "[멀티쓰레드] 쓰레드 생성", "url": "/posts/%EC%93%B0%EB%A0%88%EB%93%9C%EC%83%9D%EC%84%B1/", "categories": "서버, 멀티쓰레드 프로그래밍", "tags": "Thread, ThreadPool, Task", "date": "2022-01-28 14:09:00 +0900", "snippet": "Thread 생성C#에서 Thread 생성하는 방법은 간단하다.static void thread1(){ while(true) Console.WriteLine(&quot;Hello Thread!&quot;);}static void Main(string[] args) // 메인 쓰레드{ Thread t = new Thread(thread1); // 쓰레드 생성 및 작업(함수) 넘기기 t.Start(); // 쓰레드 시작 Console.WriteLine(&quot;Hello World!&quot;);}Hello World!Hello Thread!Hello Thread!Hello Thread!...프로그램에서는 기본적으로 메인 쓰레드가 있고 위 코드에서는 쓰레드를 하나 더 생성해서 수행하는 것을 보여주고 있다. 또한 메인 쓰레드는 종료하더라도 다른 쓰레드가 남아있으면 프로그램이 종료되지 않는 것을 볼 수 있다. (background에서 실행시킬 경우 메인 쓰레드가 종료되면 프로그램도 종료된다.)쓰레드를 생성할 때 여러 설정도 가능하다.static void thread1(){ for(int i = 0; i &amp;lt; 5; i++) Console.WriteLine(&quot;Hello Thread!&quot;);}static void Main(string[] args){ Thread t = new Thread(thread1); // 쓰레드 생성 및 작업 넘기기 t.Name = &quot;Test Thread&quot;; // 쓰레드 이름 지정(디버깅할때 확인해볼 수 있다) t.IsBackground = true; // background에서 실행되도록 설정할 수 있다(기본 설정은 false) t.Start(); // 쓰레드 시작 Console.WriteLine(&quot;Waiting for Thread!&quot;); t.Join(); // 쓰레드가 종료될때까지 기다린다. Console.WriteLine(&quot;Hello World!&quot;);}Waiting for Thread!Hello Thread!Hello Thread!Hello Thread!Hello Thread!Hello Thread!Hello World!필요할 때 매번 쓰레드를 생성해서 관리해도 되긴 하지만 사실 쓰레드를 생성하는 것은 큰 부담이 되는 작업이다. 그렇기에 매번 쓰레드를 생성하지 않고 이전에 생성했던 것을 재사용하는 방법으로 ThreadPool을 활용해 볼 수 있다.ThreadPoolThreadPool은 쓰레드가 생성되고 작업을 끝낸 후에 사라지지 않고 Queue에 대기하고 있다가 또 작업이 들어왔을 때 그 작업을 들고가서 수행한다. 쓰레드를 매번 생성하고 지우는 것이 아니라 이미 생성해 놓은 쓰레드를 활용하는 것이기에 부담을 좀 줄일 수 있다. 또한 쓰레드 개수를 제한할 수 있기 때문에 쓰레드가 무한히 막 생성되는 것을 방지할 수 있다. 다만 오래걸리는 작업들을 수행시켰을 경우 쓰레드를 오랫동안 붙잡게 되어 쓰레드 부족으로 다른 작업들을 못하게 될 수도 있다.static void thread1(object state){ for(int i = 0; i &amp;lt; 5; i++) Console.WriteLine(&quot;Hello Thread!&quot;);}static void Main(string[] args){ ThreadPool.SetMinThreads(1, 1); // 쓰레드 최소 개수 1 ThreadPool.SetMaxThreads(5, 5); // 쓰레드 최대 개수 5 for (int i = 0; i &amp;lt; 5; i++) ThreadPool.QueueUserWorkItem((obj) =&amp;gt; { while(true){ } }); // 람다식을 이용해 일부러 끝나지 않는 작업을 넘김 ThreadPool.QueueUserWorkItem(thread1); // 쓰레드 부족으로 실행이 안됨}오래 걸리는 작업일 경우 ThreadPool에서 쓰레드를 사용하지 않고 따로 생성해서 관리하는 것이 효율적일 수 있다. 사실 이러한 점들을 효율적으로 관리할 수 있는 방법으로 Task가 있다.TaskThread와 사용법이 비슷하며 기본적으로 ThreadPool에서 쓰레드를 가져와 작업을 수행한다. 다만 오래 걸릴 것같은 작업은 따로 생성해서 관리할 수 있다.static void thread1(object state){ for(int i = 0; i &amp;lt; 5; i++) Console.WriteLine(&quot;Hello Thread!&quot;);}static void Main(string[] args){ ThreadPool.SetMinThreads(1, 1); ThreadPool.SetMaxThreads(5, 5); for (int i = 0; i &amp;lt; 5; i++) { // Task도 ThreadPool에서 쓰레드를 가져오지만 // 오래걸릴 것같은 작업은 이렇게 따로 지정해놓으면 Task에서 따로 관리한다. Task t = new Task(() =&amp;gt; { while (true) { } }, TaskCreationOptions.LongRunning); t.Start(); } ThreadPool.QueueUserWorkItem(thread1); // 실행되는 것을 볼 수 있다. while (true) { } // 메인쓰레드가 종료되지 않도록}Hello Thread!Hello Thread!Hello Thread!Hello Thread!Hello Thread!static void thread1(object state){ for(int i = 0; i &amp;lt; 5; i++) Console.WriteLine(&quot;Hello Thread!&quot;);}static void Main(string[] args){ ThreadPool.SetMinThreads(1, 1); ThreadPool.SetMaxThreads(5, 5); for (int i = 0; i &amp;lt; 5; i++) { Task t = new Task(() =&amp;gt; { while (true) { } }); t.Start(); } ThreadPool.QueueUserWorkItem(thread1); // 실행되지 않는다 while (true) { } // 메인쓰레드가 종료되지 않도록}C#에서 보통 쓰레드를 직접생성해서 관리할 일는 거의 없고 ThreadPool 개념과 Task만 잘 사용해도 충분하다." }, { "title": "[멀티쓰레드] 멀티쓰레드 개론", "url": "/posts/%EB%A9%80%ED%8B%B0%EC%93%B0%EB%A0%88%EB%93%9C%EA%B0%9C%EB%A1%A0/", "categories": "서버, 멀티쓰레드 프로그래밍", "tags": "멀티쓰레드, multithread", "date": "2022-01-27 16:44:00 +0900", "snippet": "멀티쓰레드출처:싱글스레드(Single thread)vs멀티스레드(Multi thread)쓰레드란 어떠한 프로그램 내에서 실행되는 흐름의 단위이다. 둘 이상의 쓰레드가 동시에 작업을 수행하는 것을 멀티쓰레드라고 한다. 실제로는 프로세서(CPU 코어)가 여러 쓰레드를 빠르게 번갈아가며 실행시키는데 이로 인해 여러 쓰레드가 동시에 실행되는 것처럼 보이게 된다.컴퓨터에서 동시에 처리할 수 있는 최대 작업 수는 CPU 코어 수와 같다. 그렇기에 CPU 코어 수보다 더 많은 쓰레드가 실행되면 각 코어는 여러 쓰레드를 번갈아가며 실행하게 된다.멀티쓰레드를 사용할 경우 작업들을 병행적으로 실행시킬 수 있어 효율적일 수 있지만 실행 할 쓰레드가 교체되는 것을 context switching이라고 하는데 context switching 작업이 결코 가볍지 않기 때문에 많은 수의 쓰레드를 실행시키는 것이 꼭 좋은 성능을 보여주는 것은 아니다.출처:멀티쓰레드또한 멀티쓰레드를 메모리영역에서 보면 Heap 영역과 데이터 영역은 서로 공유하며 사용하고 스택 영역은 각 쓰레드마다 구분되게 할당되어 사용한다. 그렇기에 멀티쓰레드 환경에서 스택 영역에 접근하는 것은 큰 문제가 되지 않지만 동시에 공유되는 영역에 접근하게 되는 것은 문제가 발생할 수 있다." } ]
