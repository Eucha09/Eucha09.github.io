---
title: "[서버] 컴파일러 최적화"
author:
  name: define_chan
  link: https://eucha09.github.io/about/
date: 2022-02-11 17:08:00 +0900
categories: [서버(Server), 멀티쓰레드 프로그래밍(Multi-thread programming)]
tags: [컴파일러 최적화, Release 모드]     # TAG names should always be lowercase
---

## **컴파일러 최적화(Release 모드)**

간단한 멀티쓰레드 코드를 작성해보자.

```c#
static bool _stop = false; // 전역 변수는 쓰레드 간 공유된다.

static void Thread1()
{
    Console.WriteLine("쓰레드 시작!");

    while(_stop == false)
    {
        // 누군가가 stop 신호를 해주기를 기다린다.
    }

    Console.WriteLine("쓰레드 종료!");
}

static void Main(String[] args)
{
    Task t = new Task(Thread1);
    t.Start();

    Thread.Sleep(1000); // 1초 대기

    _stop = true;

    Console.WriteLine("Stop 호출");
    Console.WriteLine("종료 대기중");

    t.Wait(); // Thread1이 종료될때까지 기다린다.

    Console.WriteLine("종료 성공");
}
```

정상 실행이 된다면 아래와 같이 결과가 나타날 것이다.(마지막에 종료 성공이 떴다면 정상)

```console
쓰레드 시작!
쓰레드 종료!
Stop 호출
종료 대기중
종료 성공
```

그러나 지금은 Debug 모드로 컴파일을 했지만 Release 모드로 컴파일을 한다면 문제가 발생할 것이다.(상황에 따라 다를 수 있음)

![Release모드](/assets/img/posts/server/release모드선택.png){: w="400" }
_Release모드 선택 방법_

Release 모드로 컴파일했을 경우 실행 결과

```console
쓰레드 시작!
Stop 호출
종료 대기중
```

종료 대기중에서 더이상 넘어가지 않는 것을 볼 수 있다.

이러한 현상이 발생하는 이유는 컴파일러 최적화하는 과정에 있다.
Release 모드는 보통 프로그램 개발이 완료되어 최종 배포할 때 사용하는데 이때 여러 최적화가 이루어져 프로그램이 빠르게 실행되도록 한다.   
그러나 최적화가 되는 과정에서 의도했던 것과 다르게 바뀌는 경우가 있을 수 있다.

위 코드에서 while문 부분에 중단점을 걸어놓고 Release모드 상태에서 디버깅을 돌려보자.(디버깅을 실행했을 때 경고창이 뜬다면 '[내 코드]는 사용 안 함 그리고 계속'을 선택해주면 된다.)

![Release디버깅](/assets/img/posts/server/release디버깅.png){: w="700" }
_while문에 중단점 지정_

디버깅 실행 후 중단점에서 멈추었다면 '디버그 -> 창 -> 디스어셈블리'를 눌러보면 어셈블리어로 변형된 코드를 볼 수 있다.

![디스어셈블리](/assets/img/posts/server/release디스어셈블리.png){: w="700" }
_디스어셈블리 창_

어셈블리어를 몰라도 괜찮지만 어떤부분이 문제인지 확인해보기 위해 while문 부분만 간단하게 해석해보자면

```console
00007FFC8EEB2D36  movzx       ecx,byte ptr [7FFC8EF3FBF2h]  ; ecx에 데이터를 불러와서 저장

            while(_stop == false)
00007FFC8EEB2D3D  test        ecx,ecx     ; ecx가 0인지 1인지 검사
00007FFC8EEB2D3F  je          serverTest.Program.Thread1()+01Dh (07FFC8EEB2D3Dh)  ; 0이라면 바로 윗 줄로 점프
```

ecx라는 레지스터에 어떠한 데이터를 꺼내와서 저장하고 ecx가 0인지 1인지 검사한 후 0이라면 다시 검사 단계로 점프하여 반복하는 것이다. 결론은 ecx가 0(false)이라면 무한 반복하게 되는 것이다. 의사코드로 간단하게 나타내보면

```c#
/*
while(_stop == false)
{
    // 누군가가 stop 신호를 해주기를 기다린다.
}
*/

// 최적화하는 과정에서 이런식으로 변형된 느낌
if(_stop == false)
{
    while(true)
    {

    }
}
```

최적화하는 과정에서 위 형식으로 변형이 이루어진거나 다름없다.    
컴파일러는 이 코드가 멀티쓰레드 환경에서 실행된다라는 것을 고려하지않고 현재 코드만 보았을 때 위 처럼 바꾸어도 결과는 똑같다고 생각하고 바꾸어버린 것이다.

일단 위 문제에서는 static bool _stop 앞에 volatile를 붙여주면 된다.   
volatile를 붙이면 휘발성이라는 의미로 언제 어떻게든 바뀔 수 있으니 최적화를 하지말라는 의미가 된다.
