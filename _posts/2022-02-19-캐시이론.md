---
title: "[서버] 캐시 이론"
author:
  name: define_chan
  link: https://eucha09.github.io/about/
date: 2022-02-19 13:57:00 +0900
categories: [서버(Server), 멀티쓰레드 프로그래밍(Multi-thread programming)]
tags: [캐시, 지역성, cache, locality]     # TAG names should always be lowercase
---

## **컴퓨터 구조 원리 - 캐시(cache)**

![캐시](/assets/img/posts/server/캐시.png){: w="700"}
_컴퓨터 구조 - 캐시_

**캐시(cache)**는 **데이터를 미리 복사해 놓는 임시 장소**로, 데이터에 접근하는 시간을 줄이기 위해 사용된다.   

컴퓨터는 기본적으로 프로그램을 메모리(RAM)에 올려놓고 실행시키지만 매번 메모리(RAM)에 접근하고 갱신하기에는 오래 걸리기에 연산장치와 메모리(RAM) 사이에 캐시장치를 두어 필요한 데이터를 미리 복사해 놓고 사용한다.

## **캐시 철학(지역성의 원리)**

캐시는 효율적으로 동작하기 위해 지역성의 원리를 사용하는데 지역성이란 데이터 접근이 시간적 혹은 공간적으 가깝게 일어나는 것을 의미한다.

* **시간 지역성(Temporal locality)** - 최근에 접근한 데이터가 잠시 후 한번 더 접근할 가능성이 높다.

* **공간 지역성(Spatial locality)** - 방금 접근한 데이터와 인접한 데이터가 잠시 후 접근할 가능성이 높다.

이러한 지역성의 원리를 사용해 필요해질 것 같은 데이터들을 미리 복사해온다.

## **지역성 테스트**

간단하게 캐시가 잘 동작하고 있는지 확인해 볼 수 있다.

```c#
int[,] arr = new int[10000, 10000];
long start, end;

start = DateTime.Now.Ticks;
for (int i = 0; i < 10000; i++)
    for (int j = 0; j < 10000; j++)
        arr[i, j] = 1;
end = DateTime.Now.Ticks;
Console.WriteLine($"[i, j] 순서 걸린 시간 {end - start}");

start = DateTime.Now.Ticks;
for (int i = 0; i < 10000; i++)
    for (int j = 0; j < 10000; j++)
        arr[j, i] = 1;
end = DateTime.Now.Ticks;
Console.WriteLine($"[j, i] 순서 걸린 시간 {end - start}");
```
```console
[i, j] 순서 걸린 시간 3280550
[j, i] 순서 걸린 시간 5786319
```

위 코드를 실행시켜보면 똑같은 구문인것 같지만 걸리는 시간이 거의 2배 가까이 차이나는 것을 볼 수 있다.   
결과적으로는 2차원배열에 접근한다라는 것은 같지만 두 구문의 차이는 접근 순서에 있다.

배열의 크기를 4 * 4라고 가정하고 접근 순서를 간단하게 표현해보자면   

첫 번째 [i, j] 순서는 배열을 메모리 주소대로 나열하였을 때 순차적으로 접근하지만   
**[1][2][3][4]&nbsp;&nbsp;&nbsp;[5][6][7][8]&nbsp;&nbsp;&nbsp;[9][10][11][12]&nbsp;&nbsp;&nbsp;[13][14][15][16]**

두 번째 [j, i] 순서는 띄엄띄엄 접근한다라는 것을 알 수 있다.   
**[1][5][9][13]&nbsp;&nbsp;&nbsp;[2][6][10][14]&nbsp;&nbsp;&nbsp;[3][7][11][15]&nbsp;&nbsp;&nbsp;[4][8][12][16]**

앞에 지역성에서 공간 지역성이 있었는데 여기서 공간 지역성을 확인해 볼 수 있다.   
공간 지역성에 따르면 배열에서의 첫 번째 메모리에 접근할 때 주변 인접한 메모리들까지 캐시에 복사해오는데, [i, j] 순서의 경우 인접한 순서대로 접근하였기에 캐시를 충분히 잘 활용할 수 있었고 [j, i] 순서의 경우 캐시를 제대로 활용하지 못해 앞에 보다 수행시간이 더 오래걸렸음을 알 수 있다.
