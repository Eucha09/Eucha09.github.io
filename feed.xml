<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://eucha09.github.io//</id><title>define_chan</title><subtitle>define_chan, blog, 개발노트</subtitle> <updated>2022-06-01T17:43:51+09:00</updated> <author> <name>정의찬</name> <uri>https://eucha09.github.io//</uri> </author><link rel="self" type="application/atom+xml" href="https://eucha09.github.io//feed.xml"/><link rel="alternate" type="text/html" hreflang="ko" href="https://eucha09.github.io//"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 정의찬 </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>[멀티쓰레드] AutoResetEvent</title><link href="https://eucha09.github.io//posts/AutoResetEvent/" rel="alternate" type="text/html" title="[멀티쓰레드] AutoResetEvent" /><published>2022-06-01T15:02:00+09:00</published> <updated>2022-06-01T15:02:00+09:00</updated> <id>https://eucha09.github.io//posts/AutoResetEvent/</id> <content src="https://eucha09.github.io//posts/AutoResetEvent/" /> <author> <name>{"name"=>"define_chan", "link"=>"https://eucha09.github.io/about/"}</name> </author> <category term="서버" /> <category term="멀티쓰레드 프로그래밍" /> <summary> Lock 구현 이론 Lock 구현 이론 앞 포스트에서 Lock 구현 방법에 대해 얘기를 해보았다. 대략 3가지 방법이 있었는데, 그냥 무작정 기다린다. 일단 다른 작업으로 돌아가 있다가 나중에 다시 와본다. Event call back 방식으로 누군가에게 다시 사용할 수 있는 상태가 되면 호출해 달라한다. 1번 방법은 SpinLock이라고 부른다고 하였고 이전 포스트에서 직접 구현해보기도 하였다. SpinLock 2번 방법은 그냥 무작정 기다리는것이 아닌 일단 CPU 소유권을 양보하였다가 나중에 다시 시도하는 방식이다. 이또한 Context Switching을 배워보면서 간단하게 구현해보았다. Context Switching 3번 방법은 커널(운영체제)한테 Event ca... </summary> </entry> <entry><title>[멀티쓰레드] Context Switching</title><link href="https://eucha09.github.io//posts/ContextSwitching/" rel="alternate" type="text/html" title="[멀티쓰레드] Context Switching" /><published>2022-05-30T15:51:00+09:00</published> <updated>2022-06-01T17:43:19+09:00</updated> <id>https://eucha09.github.io//posts/ContextSwitching/</id> <content src="https://eucha09.github.io//posts/ContextSwitching/" /> <author> <name>{"name"=>"define_chan", "link"=>"https://eucha09.github.io/about/"}</name> </author> <category term="서버" /> <category term="멀티쓰레드 프로그래밍" /> <summary> Context Switching Context Switching이란 하나의 프로세스(또는 쓰레드)가 CPU를 사용 중인 상태에서 다른 프로세스(또는 쓰레드)가 CPU를 사용하도록 교체하는 작업을 말한다. 이 과정속에서 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 상태를 적재하는 작업이 이루어진다. 보통 일반적으로 운영체제가 각 프로세스한테 실행 시간(timeslice)을 배정해서, 그 시간만큼 프로세스가 실행되고, 시간이 끝나면 CPU 소유권을 반납하여 다른 프로세스가 소유권을 받아 실행되도록 한다(Context Switching). 근데 만약 CPU 소유권을 받았는데 딱히 할일이 없다면 미연에 소유권을 받납할 수도 있다. 앞 포스트에서의 SpinLock을 예로 들어보자면 SpinLock... </summary> </entry> <entry><title>[멀티쓰레드] SpinLock</title><link href="https://eucha09.github.io//posts/SpinLock/" rel="alternate" type="text/html" title="[멀티쓰레드] SpinLock" /><published>2022-04-05T11:45:00+09:00</published> <updated>2022-04-05T11:45:00+09:00</updated> <id>https://eucha09.github.io//posts/SpinLock/</id> <content src="https://eucha09.github.io//posts/SpinLock/" /> <author> <name>{"name"=>"define_chan", "link"=>"https://eucha09.github.io/about/"}</name> </author> <category term="서버" /> <category term="멀티쓰레드 프로그래밍" /> <summary> SpinLock SpinLock은 임계 구역(Critical Section)에 진입이 불가능할 때 진입이 가능할 때까지 루프를 돌면서 재시도하는 방식으로 구현된 락을 가르킨다. 화장실문에 비유하자면 누가 화장실에 들어가 문을 잠궜을 때 내가 들어갈 수 있을 때까지 문을 열려고 시도하는 것이다. SpinLock 구현 SpinLock을 구현하는 방법은 쉽지만 중요한 부분을 놓치기가 쉽다. 일단 그냥 단순히 생각나는대로 구현해보자. 먼저 인터페이스로는 들어가고 나오는 함수가 있어야 할 것이다. 그리고 들어가려고 할 때 이미 누가 lock을 걸어뒀다면 lock이 풀릴 때까지 루프 형식으로 기다려야할 것이다. 위 사항 그대로 구현해보면 아래와 같이 구현해볼 수 있다. class SpinLock ... </summary> </entry> <entry><title>[멀티쓰레드] Lock 구현 이론</title><link href="https://eucha09.github.io//posts/Lock%EA%B5%AC%ED%98%84%EC%9D%B4%EB%A1%A0/" rel="alternate" type="text/html" title="[멀티쓰레드] Lock 구현 이론" /><published>2022-04-04T14:00:00+09:00</published> <updated>2022-04-04T14:00:00+09:00</updated> <id>https://eucha09.github.io//posts/Lock%EA%B5%AC%ED%98%84%EC%9D%B4%EB%A1%A0/</id> <content src="https://eucha09.github.io//posts/Lock%EA%B5%AC%ED%98%84%EC%9D%B4%EB%A1%A0/" /> <author> <name>{"name"=>"define_chan", "link"=>"https://eucha09.github.io/about/"}</name> </author> <category term="서버" /> <category term="멀티쓰레드 프로그래밍" /> <summary> Lock 구현 이론 Lock을 직접 구현해본다고 생각하고 Lock이 어떤 철학으로 어떤식으로 구현될 수 있을지 생각해보자. 일단 기본적으로 당연히 Lock의 역할을 하기 위해서는 Critical Section(임계 구역)에 두 프로세스가 동시에 진입하지 못하도록 해야할 것이다. 그 다음으로는 이미 다른 프로세스가 들어와 사용하고 있을 때 어떻게 처리할지를 생각해봐야 할 것이다. 일상생활에 비유해보자면 공용 화장실에 이미 누가 들어가 문을 잠군 상태이고 난 문앞에서 기다리고 있는 상황이다. 이때 내가 할 수 있는 행동으로는 아래와 같을 것이다. 그냥 무작정 기다린다. 일단 돌아가 있다가 나중에 다시 와본다. 주변에 직원분이 있다면 부탁드리고 돌아와 있다가 직원분이 화장실이 비었다고... </summary> </entry> <entry><title>[멀티쓰레드] DeadLock</title><link href="https://eucha09.github.io//posts/DeadLock/" rel="alternate" type="text/html" title="[멀티쓰레드] DeadLock" /><published>2022-04-04T13:00:00+09:00</published> <updated>2022-06-01T17:43:19+09:00</updated> <id>https://eucha09.github.io//posts/DeadLock/</id> <content src="https://eucha09.github.io//posts/DeadLock/" /> <author> <name>{"name"=>"define_chan", "link"=>"https://eucha09.github.io/about/"}</name> </author> <category term="서버" /> <category term="멀티쓰레드 프로그래밍" /> <summary> DeadLock DeadLock(데드락, 교착상태)이란 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태를 가리킨다. DeadLock 상황을 간단하게 만들어보자. 예를 들어 SessionManager와 User들을 관리하는 UserManager 두 클래스가 있다. 멀티쓰레드 환경에서 돌아가다보니 각 클래스에서는 lock을 하나씩 쥐고 있고 서로 호출할 일이 있다고 해보자. SesstionManager class SessionManager { static object _lock = new object(); public static void TestSession() { lock(_lock) //... </summary> </entry> </feed>
